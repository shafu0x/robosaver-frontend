{
  "address": "0xF32dcd39F3f8be5c141df34f7b2A539eea9F9ff3",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract IVault",
          "name": "_vault",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "contract IAsset[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "minAmountsOut",
              "type": "uint256[]"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            },
            {
              "internalType": "bool",
              "name": "toInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.ExitPoolRequest",
          "name": "request",
          "type": "tuple"
        }
      ],
      "name": "queryExit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "bptIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "amountsOut",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "poolId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "contract IAsset[]",
              "name": "assets",
              "type": "address[]"
            },
            {
              "internalType": "uint256[]",
              "name": "maxAmountsIn",
              "type": "uint256[]"
            },
            {
              "internalType": "bytes",
              "name": "userData",
              "type": "bytes"
            },
            {
              "internalType": "bool",
              "name": "fromInternalBalance",
              "type": "bool"
            }
          ],
          "internalType": "struct IVault.JoinPoolRequest",
          "name": "request",
          "type": "tuple"
        }
      ],
      "name": "queryJoin",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "bptOut",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "amountsIn",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "vault",
      "outputs": [
        {
          "internalType": "contract IVault",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x21f6454b0b1351984f4dc86bda2ba8599ba90fe9264f16625d5ed4cceae78543",
  "receipt": {
    "to": null,
    "from": "0x02D22f2342C7c52f779Fa631d5313b5af8495703",
    "contractAddress": "0xF32dcd39F3f8be5c141df34f7b2A539eea9F9ff3",
    "transactionIndex": 0,
    "gasUsed": "876400",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x271ada6e959d3d6740a30a2e5da45095f670e122a071b3ccaed2f416fe796a18",
    "transactionHash": "0x21f6454b0b1351984f4dc86bda2ba8599ba90fe9264f16625d5ed4cceae78543",
    "logs": [],
    "blockNumber": 24226734,
    "cumulativeGasUsed": "876400",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xba1222227c37746aDA22d10Da6265E02E44400DD"
  ],
  "solcInputHash": "74b30510f56cfc64a70ac36466ef55b0",
  "metadata": "{\"compiler\":{\"version\":\"0.7.1+commit.f4a555be\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IVault\",\"name\":\"_vault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IAsset[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.ExitPoolRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"queryExit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bptIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IAsset[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.JoinPoolRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"queryJoin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bptOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsIn\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"This contract simply builds on top of the Balancer V2 architecture to provide useful helpers to users. It connects different functionalities of the protocol components to allow accessing information that would have required a more cumbersome setup if we wanted to provide these already built-in.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lib/helpers/BalancerHelpers.sol\":\"BalancerHelpers\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":9999},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xbd74f587ab9b9711801baf667db1426e4a03fd2d7f15af33e0e0d0394e7cef76\",\"license\":\"MIT\"},\"contracts/lib/helpers/AssetHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../../vault/interfaces/IAsset.sol\\\";\\nimport \\\"../../vault/interfaces/IWETH.sol\\\";\\n\\nabstract contract AssetHelpers {\\n    // solhint-disable-next-line var-name-mixedcase\\n    IWETH private immutable _weth;\\n\\n    // Sentinel value used to indicate WETH with wrapping/unwrapping semantics. The zero address is a good choice for\\n    // multiple reasons: it is cheap to pass as a calldata argument, it is a known invalid token and non-contract, and\\n    // it is an address Pools cannot register as a token.\\n    address private constant _ETH = address(0);\\n\\n    constructor(IWETH weth) {\\n        _weth = weth;\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _WETH() internal view returns (IWETH) {\\n        return _weth;\\n    }\\n\\n    /**\\n     * @dev Returns true if `asset` is the sentinel value that represents ETH.\\n     */\\n    function _isETH(IAsset asset) internal pure returns (bool) {\\n        return address(asset) == _ETH;\\n    }\\n\\n    /**\\n     * @dev Translates `asset` into an equivalent IERC20 token address. If `asset` represents ETH, it will be translated\\n     * to the WETH contract.\\n     */\\n    function _translateToIERC20(IAsset asset) internal view returns (IERC20) {\\n        return _isETH(asset) ? _WETH() : _asIERC20(asset);\\n    }\\n\\n    /**\\n     * @dev Same as `_translateToIERC20(IAsset)`, but for an entire array.\\n     */\\n    function _translateToIERC20(IAsset[] memory assets) internal view returns (IERC20[] memory tokens) {\\n        tokens = new IERC20[](assets.length);\\n        for (uint256 i = 0; i < assets.length; ++i) {\\n            tokens[i] = _translateToIERC20(assets[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Interprets `asset` as an IERC20 token. This function should only be called on `asset` if `_isETH` previously\\n     * returned false for it, that is, if `asset` is guaranteed not to be the ETH sentinel value.\\n     */\\n    function _asIERC20(IAsset asset) internal pure returns (IERC20) {\\n        return IERC20(address(asset));\\n    }\\n}\\n\",\"keccak256\":\"0xae0070dd2f3a3c6413f4a649db424949ae5402210c9b3b7640e108a47164923b\",\"license\":\"GPL-3.0-or-later\"},\"contracts/lib/helpers/Authentication.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\n\\nabstract contract Authentication {\\n    /**\\n     * @dev Reverts unless the caller is allowed to call this function. Should only be applied to external functions.\\n     */\\n    modifier authenticate() {\\n        _authenticateCaller();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts unless the caller is allowed to call the entry point function.\\n     */\\n    function _authenticateCaller() internal view {\\n        // Each external function is dynamically assigned a role ID as the hash of the contract address\\n        // and the function selector.\\n        bytes32 roleId = keccak256(abi.encodePacked(address(this), msg.sig));\\n        _require(_canPerform(roleId, msg.sender), Errors.SENDER_NOT_ALLOWED);\\n    }\\n\\n    function _canPerform(bytes32 roleId, address user) internal view virtual returns (bool);\\n}\\n\",\"keccak256\":\"0xd78469e9231fa20f0844d18cf07eb396c0d2be200292b67659ddb681a504dcb3\",\"license\":\"GPL-3.0-or-later\"},\"contracts/lib/helpers/BalancerErrors.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n// solhint-disable\\n\\n/**\\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\\n * supported.\\n */\\nfunction _require(bool condition, uint256 errorCode) pure {\\n    if (!condition) _revert(errorCode);\\n}\\n\\n/**\\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\\n */\\nfunction _revert(uint256 errorCode) pure {\\n    // We're going to dynamically create a revert string based on the error code, with the following format:\\n    // 'BAL#{errorCode}'\\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\\n    //\\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\\n    // number (8 to 16 bits) than the individual string characters.\\n    //\\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\\n    assembly {\\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\\n        // the '0' character.\\n\\n        let units := add(mod(errorCode, 10), 0x30)\\n\\n        errorCode := div(errorCode, 10)\\n        let tenths := add(mod(errorCode, 10), 0x30)\\n\\n        errorCode := div(errorCode, 10)\\n        let hundreds := add(mod(errorCode, 10), 0x30)\\n\\n        // With the individual characters, we can now construct the full string. The \\\"BAL#\\\" part is a known constant\\n        // (0x42414c23): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\\n        // characters to it, each shifted by a multiple of 8.\\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\\n        // array).\\n\\n        let revertReason := shl(200, add(0x42414c23000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\\n\\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\\n        // message will have the following layout:\\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\\n\\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\\n        // The string length is fixed: 7 characters.\\n        mstore(0x24, 7)\\n        // Finally, the string itself is stored.\\n        mstore(0x44, revertReason)\\n\\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\\n        revert(0, 100)\\n    }\\n}\\n\\nlibrary Errors {\\n    // Math\\n    uint256 internal constant ADD_OVERFLOW = 0;\\n    uint256 internal constant SUB_OVERFLOW = 1;\\n    uint256 internal constant SUB_UNDERFLOW = 2;\\n    uint256 internal constant MUL_OVERFLOW = 3;\\n    uint256 internal constant ZERO_DIVISION = 4;\\n    uint256 internal constant ZERO_MOD = 5;\\n    uint256 internal constant DIV_INTERNAL = 6;\\n    uint256 internal constant X_OUT_OF_BOUNDS = 7;\\n    uint256 internal constant Y_OUT_OF_BOUNDS = 8;\\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 9;\\n\\n    // Input\\n    uint256 internal constant OUT_OF_BOUNDS = 100;\\n    uint256 internal constant UNSORTED_ARRAY = 101;\\n    uint256 internal constant UNSORTED_TOKENS = 102;\\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\\n    uint256 internal constant TOKEN_NOT_CONTRACT = 104;\\n\\n    // Shared pools\\n    uint256 internal constant MIN_TOKENS = 200;\\n    uint256 internal constant MAX_TOKENS = 201;\\n    uint256 internal constant MAX_SWAP_FEE = 202;\\n    uint256 internal constant MIN_SWAP_FEE = 203;\\n    uint256 internal constant MINIMUM_BPT = 204;\\n    uint256 internal constant CALLER_NOT_VAULT = 205;\\n    uint256 internal constant UNINITIALIZED = 206;\\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\\n    uint256 internal constant UNHANDLED_JOIN_KIND = 209;\\n    uint256 internal constant UNHANDLED_EXIT_KIND = 210;\\n\\n    // Stable pool\\n    uint256 internal constant MIN_AMP = 300;\\n    uint256 internal constant MAX_AMP = 301;\\n    uint256 internal constant MIN_WEIGHT = 302;\\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\\n\\n    // Weighted pool\\n    uint256 internal constant MAX_IN_RATIO = 400;\\n    uint256 internal constant MAX_OUT_RATIO = 401;\\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 402;\\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 403;\\n\\n    // Lib\\n    uint256 internal constant REENTRANCY = 500;\\n    uint256 internal constant SENDER_NOT_ALLOWED = 501;\\n    uint256 internal constant EMERGENCY_PERIOD_ON = 502;\\n    uint256 internal constant EMERGENCY_PERIOD_FINISHED = 503;\\n    uint256 internal constant MAX_EMERGENCY_PERIOD = 504;\\n    uint256 internal constant MAX_EMERGENCY_PERIOD_CHECK_EXT = 505;\\n    uint256 internal constant INSUFFICIENT_BALANCE = 506;\\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 507;\\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 508;\\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 509;\\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 510;\\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 511;\\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 512;\\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 513;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 514;\\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 515;\\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 516;\\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 517;\\n    uint256 internal constant SAFE_ERC20_OP_DIDNT_SUCCEED = 518;\\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 519;\\n    uint256 internal constant SAFE_ERC20_APPROVE_NON_ZERO_ALLOWANCE = 520;\\n    uint256 internal constant SAFE_ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 521;\\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 522;\\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 523;\\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE_CALL = 524;\\n    uint256 internal constant ADDRESS_CALL_TO_NON_CONTRACT = 525;\\n    uint256 internal constant ADDRESS_STATIC_CALL_NOT_CONTRACT = 526;\\n    uint256 internal constant ADDRESS_CALL_FAILED = 527;\\n    uint256 internal constant ADDRESS_STATIC_CALL_FAILED = 528;\\n    uint256 internal constant ADDRESS_STATIC_CALL_VALUE_FAILED = 529;\\n    uint256 internal constant CREATE2_INSUFFICIENT_BALANCE = 530;\\n    uint256 internal constant CREATE2_BYTECODE_ZERO = 531;\\n    uint256 internal constant CREATE2_DEPLOY_FAILED = 532;\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_128 = 533;\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_64 = 534;\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_32 = 535;\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_16 = 536;\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_8 = 537;\\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 538;\\n    uint256 internal constant SAFE_CAST_VALUE_NOT_POSITIVE = 539;\\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 540;\\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 541;\\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 542;\\n    uint256 internal constant ENUMERABLE_NON_EXISTENT_KEY = 543;\\n    uint256 internal constant SET_ROLE_SENDER_NOT_ADMIN = 544;\\n    uint256 internal constant INVALID_SIGNATURE = 545;\\n\\n    // Vault\\n    uint256 internal constant INVALID_POOL_ID = 600;\\n    uint256 internal constant CALLER_NOT_POOL = 601;\\n    uint256 internal constant EXIT_BELOW_MIN = 602;\\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 603;\\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 604;\\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 605;\\n    uint256 internal constant JOIN_ABOVE_MAX = 606;\\n    uint256 internal constant SWAP_LIMIT = 607;\\n    uint256 internal constant SWAP_DEADLINE = 608;\\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 609;\\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 610;\\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 611;\\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 612;\\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 613;\\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 614;\\n    uint256 internal constant INSUFFICIENT_ETH = 615;\\n    uint256 internal constant UNALLOCATED_ETH = 616;\\n    uint256 internal constant ETH_TRANSFER = 617;\\n    uint256 internal constant INVALID_TOKEN = 618;\\n    uint256 internal constant TOKENS_MISMATCH = 619;\\n    uint256 internal constant TOKEN_NOT_REGISTERED = 620;\\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 621;\\n    uint256 internal constant TOKENS_ALREADY_SET = 622;\\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 623;\\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 624;\\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 625;\\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 626;\\n\\n    // Fees\\n    uint256 internal constant SWAP_FEE_TOO_HIGH = 700;\\n    uint256 internal constant FLASH_LOAN_FEE_TOO_HIGH = 701;\\n    uint256 internal constant INSUFFICIENT_COLLECTED_FEES = 702;\\n}\\n\",\"keccak256\":\"0x32b4cbf77ee021500bcedccb3634d25ba848d37f84bfa6a006632a0281392bb8\",\"license\":\"GPL-3.0-or-later\"},\"contracts/lib/helpers/BalancerHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../math/Math.sol\\\";\\nimport \\\"../math/FixedPoint.sol\\\";\\n\\nimport \\\"./InputHelpers.sol\\\";\\nimport \\\"./AssetHelpers.sol\\\";\\nimport \\\"./BalancerErrors.sol\\\";\\n\\nimport \\\"../../pools/BasePool.sol\\\";\\nimport \\\"../../vault/ProtocolFeesCollector.sol\\\";\\nimport \\\"../../vault/interfaces/IWETH.sol\\\";\\nimport \\\"../../vault/interfaces/IVault.sol\\\";\\nimport \\\"../../vault/balances/BalanceAllocation.sol\\\";\\n\\n/**\\n * @dev This contract simply builds on top of the Balancer V2 architecture to provide useful helpers to users.\\n * It connects different functionalities of the protocol components to allow accessing information that would\\n * have required a more cumbersome setup if we wanted to provide these already built-in.\\n */\\ncontract BalancerHelpers is AssetHelpers {\\n    using Math for uint256;\\n    using BalanceAllocation for bytes32;\\n    using BalanceAllocation for bytes32[];\\n\\n    IVault public immutable vault;\\n\\n    constructor(IVault _vault) AssetHelpers(_vault.WETH()) {\\n        vault = _vault;\\n    }\\n\\n    function queryJoin(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        IVault.JoinPoolRequest memory request\\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\\n        (address pool, ) = vault.getPool(poolId);\\n        (uint256[] memory balances, uint256 latestBlockNumber) = _validateAssetsAndGetBalances(poolId, request.assets);\\n        ProtocolFeesCollector feesCollector = vault.getProtocolFeesCollector();\\n\\n        (bptOut, amountsIn) = BasePool(pool).queryJoin(\\n            poolId,\\n            sender,\\n            recipient,\\n            balances,\\n            latestBlockNumber,\\n            feesCollector.getSwapFee(),\\n            request.userData\\n        );\\n    }\\n\\n    function queryExit(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        IVault.ExitPoolRequest memory request\\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\\n        (address pool, ) = vault.getPool(poolId);\\n        (uint256[] memory balances, uint256 latestBlockNumber) = _validateAssetsAndGetBalances(poolId, request.assets);\\n        ProtocolFeesCollector feesCollector = vault.getProtocolFeesCollector();\\n\\n        (bptIn, amountsOut) = BasePool(pool).queryExit(\\n            poolId,\\n            sender,\\n            recipient,\\n            balances,\\n            latestBlockNumber,\\n            feesCollector.getSwapFee(),\\n            request.userData\\n        );\\n    }\\n\\n    function _validateAssetsAndGetBalances(bytes32 poolId, IAsset[] memory expectedAssets)\\n        internal\\n        view\\n        returns (uint256[] memory balances, uint256 latestBlockNumberUsed)\\n    {\\n        IERC20[] memory actualTokens;\\n        IERC20[] memory expectedTokens = _translateToIERC20(expectedAssets);\\n\\n        (actualTokens, balances, latestBlockNumberUsed) = vault.getPoolTokens(poolId);\\n        InputHelpers.ensureInputLengthMatch(actualTokens.length, expectedTokens.length);\\n\\n        for (uint256 i = 0; i < actualTokens.length; ++i) {\\n            IERC20 token = actualTokens[i];\\n            _require(token == expectedTokens[i], Errors.TOKENS_MISMATCH);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x67664e0cb82d0fc183645ad8cb2dc36dad8b2318a8932850fffa9eaf52903aa6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/lib/helpers/EmergencyPeriod.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Provide \\\"Emergency Stop\\\" functionality that is automatically disabled after a time, after which it\\n * turns off and can no longer be turned on.\\n *\\n * The Emergency Period end date is initialized on creation, and cannot be set longer than _MAX_EMERGENCY_PERIOD\\n * days in the future. During this period `_setEmergencyPeriod` can be called to either activate\\n * or deactivate the emergency stop.\\n *\\n * If the emergency stop is active when the end date passes, it will remain active for an additional period after which\\n * it will be automatically deactivated forever. This additional time period is also set on creation, and is limited to\\n * _MAX_EMERGENCY_PERIOD_CHECK_EXT days. This provides enough time to react to the issue, even if the\\n * emergency period is about to expire.\\n */\\n// solhint-disable not-rely-on-time\\nabstract contract EmergencyPeriod {\\n    uint256 private constant _MAX_EMERGENCY_PERIOD = 90 days;\\n    uint256 private constant _MAX_EMERGENCY_PERIOD_CHECK_EXT = 30 days;\\n\\n    bool private _emergencyPeriodActive;\\n    uint256 private immutable _emergencyPeriodEndDate;\\n    uint256 private immutable _emergencyPeriodCheckEndDate;\\n\\n    event EmergencyPeriodChanged(bool active);\\n\\n    modifier noEmergencyPeriod() {\\n        _ensureInactiveEmergencyPeriod();\\n        _;\\n    }\\n\\n    constructor(uint256 emergencyPeriod, uint256 emergencyPeriodCheckExtension) {\\n        _require(emergencyPeriod <= _MAX_EMERGENCY_PERIOD, Errors.MAX_EMERGENCY_PERIOD);\\n        _require(\\n            emergencyPeriodCheckExtension <= _MAX_EMERGENCY_PERIOD_CHECK_EXT,\\n            Errors.MAX_EMERGENCY_PERIOD_CHECK_EXT\\n        );\\n\\n        _emergencyPeriodEndDate = block.timestamp + emergencyPeriod;\\n        _emergencyPeriodCheckEndDate = block.timestamp + emergencyPeriod + emergencyPeriodCheckExtension;\\n    }\\n\\n    function getEmergencyPeriod()\\n        external\\n        view\\n        returns (\\n            bool active,\\n            uint256 endDate,\\n            uint256 checkEndDate\\n        )\\n    {\\n        return (!_isEmergencyPeriodInactive(), _getEmergencyPeriodEndDate(), _getEmergencyPeriodCheckEndDate());\\n    }\\n\\n    function _setEmergencyPeriod(bool active) internal {\\n        _require(block.timestamp < _getEmergencyPeriodEndDate(), Errors.EMERGENCY_PERIOD_FINISHED);\\n        _emergencyPeriodActive = active;\\n        emit EmergencyPeriodChanged(active);\\n    }\\n\\n    function _ensureInactiveEmergencyPeriod() internal view {\\n        _require(_isEmergencyPeriodInactive(), Errors.EMERGENCY_PERIOD_ON);\\n    }\\n\\n    function _isEmergencyPeriodInactive() internal view returns (bool) {\\n        return (block.timestamp >= _getEmergencyPeriodCheckEndDate()) || !_emergencyPeriodActive;\\n    }\\n\\n    function _getEmergencyPeriodEndDate() internal view returns (uint256) {\\n        return _emergencyPeriodEndDate;\\n    }\\n\\n    function _getEmergencyPeriodCheckEndDate() internal view returns (uint256) {\\n        return _emergencyPeriodCheckEndDate;\\n    }\\n}\\n\",\"keccak256\":\"0xd4ba1117f1b8516ece3bf2a41fddc77f6bc474d39ece7af0001c70a7657f79fb\",\"license\":\"GPL-3.0-or-later\"},\"contracts/lib/helpers/InputHelpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./BalancerErrors.sol\\\";\\n\\nimport \\\"../../vault/interfaces/IAsset.sol\\\";\\n\\nlibrary InputHelpers {\\n    function ensureInputLengthMatch(uint256 a, uint256 b) internal pure {\\n        _require(a == b, Errors.INPUT_LENGTH_MISMATCH);\\n    }\\n\\n    function ensureInputLengthMatch(\\n        uint256 a,\\n        uint256 b,\\n        uint256 c\\n    ) internal pure {\\n        _require(a == b && b == c, Errors.INPUT_LENGTH_MISMATCH);\\n    }\\n\\n    function ensureArrayIsSorted(IAsset[] memory array) internal pure {\\n        address[] memory addressArray;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addressArray := array\\n        }\\n        ensureArrayIsSorted(addressArray);\\n    }\\n\\n    function ensureArrayIsSorted(IERC20[] memory array) internal pure {\\n        address[] memory addressArray;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addressArray := array\\n        }\\n        ensureArrayIsSorted(addressArray);\\n    }\\n\\n    function ensureArrayIsSorted(address[] memory array) internal pure {\\n        if (array.length < 2) {\\n            return;\\n        }\\n\\n        address previous = array[0];\\n        for (uint256 i = 1; i < array.length; ++i) {\\n            address current = array[i];\\n            _require(previous < current, Errors.UNSORTED_ARRAY);\\n            previous = current;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4b2e5eb0e673c3b3d16a4e22e369760dcfb9cd2c148d7275ba632239f812f515\",\"license\":\"GPL-3.0-or-later\"},\"contracts/lib/math/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./LogExpMath.sol\\\";\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\n/* solhint-disable private-vars-leading-underscore */\\n\\nlibrary FixedPoint {\\n    uint256 internal constant ONE = 1e18; // 18 decimal places\\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\\n\\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n\\n        uint256 c = a + b;\\n        _require(c >= a, Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Fixed Point addition is the same as regular checked addition\\n\\n        _require(b <= a, Errors.SUB_OVERFLOW);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c0 = a * b;\\n        _require(a == 0 || c0 / a == b, Errors.MUL_OVERFLOW);\\n        uint256 c1 = c0 + (ONE / 2);\\n        _require(c1 >= c0, Errors.MUL_OVERFLOW);\\n        uint256 c2 = c1 / ONE;\\n        return c2;\\n    }\\n\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\\n\\n        return product / ONE;\\n    }\\n\\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 product = a * b;\\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\\n\\n        if (product == 0) {\\n            return 0;\\n        } else {\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((product - 1) / ONE) + 1;\\n        }\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n        uint256 c0 = a * ONE;\\n        _require(a == 0 || c0 / a == ONE, Errors.DIV_INTERNAL); // mul overflow\\n        uint256 c1 = c0 + (b / 2);\\n        _require(c1 >= c0, Errors.DIV_INTERNAL); // add require\\n        uint256 c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\\n\\n            return aInflated / b;\\n        }\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            uint256 aInflated = a * ONE;\\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\\n\\n            // The traditional divUp formula is:\\n            // divUp(x, y) := (x + y - 1) / y\\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\\n            // divUp(x, y) := (x - 1) / y + 1\\n            // Note that this requires x != 0, which we already tested for.\\n\\n            return ((aInflated - 1) / b) + 1;\\n        }\\n    }\\n\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return LogExpMath.pow(x, y);\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\\n     * the true value (that is, the error function expected - actual is always positive).\\n     */\\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n        if (raw < maxError) {\\n            return 0;\\n        } else {\\n            return sub(raw, maxError);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\\n     * the true value (that is, the error function expected - actual is always negative).\\n     */\\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        uint256 raw = LogExpMath.pow(x, y);\\n        uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\\n\\n        return add(raw, maxError);\\n    }\\n\\n    /**\\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\\n     *\\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\\n     * prevents intermediate negative values.\\n     */\\n    function complement(uint256 x) internal pure returns (uint256) {\\n        return (x < ONE) ? (ONE - x) : 0;\\n    }\\n}\\n\",\"keccak256\":\"0xca7de7de59df701e78a8ca6ddc5bc0336677c01923e621389f87ed5582ae84db\",\"license\":\"GPL-3.0-or-later\"},\"contracts/lib/math/LogExpMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General internal License for more details.\\n\\n// You should have received a copy of the GNU General internal License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\n// There's plenty of linter errors caused by this file, we'll eventually\\n// revisit it to make it more readable, verfiable and testable.\\n/* solhint-disable */\\n\\n/**\\n * @title Ethereum library for logarithm and exponential functions with 18 decimal precision.\\n * @author Fernando Martinelli - @fernandomartinelli\\n * @author Sergio Yuhjtman - @sergioyuhjtman\\n * @author Daniel Fernandez - @dmf7z\\n */\\nlibrary LogExpMath {\\n    int256 constant DECIMALS = 1e18;\\n    int256 constant DOUBLE_DECIMALS = DECIMALS * DECIMALS;\\n    int256 constant PRECISION = 10**20;\\n    int256 constant DOUBLE_PRECISION = PRECISION * PRECISION;\\n    int256 constant PRECISION_LOG_UNDER_BOUND = DECIMALS - 10**17;\\n    int256 constant PRECISION_LOG_UPPER_BOUND = DECIMALS + 10**17;\\n    int256 constant EXPONENT_LB = -41446531673892822312;\\n    int256 constant EXPONENT_UB = 130700829182905140221;\\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(PRECISION);\\n\\n    int256 constant x0 = 128000000000000000000; //2\\u02c67\\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; //e\\u02c6(x0)\\n    int256 constant x1 = 64000000000000000000; //2\\u02c66\\n    int256 constant a1 = 6235149080811616882910000000; //e\\u02c6(x1)\\n    int256 constant x2 = 3200000000000000000000; //2\\u02c65\\n    int256 constant a2 = 7896296018268069516100000000000000; //e\\u02c6(x2)\\n    int256 constant x3 = 1600000000000000000000; //2\\u02c64\\n    int256 constant a3 = 888611052050787263676000000; //e\\u02c6(x3)\\n    int256 constant x4 = 800000000000000000000; //2\\u02c63\\n    int256 constant a4 = 298095798704172827474000; //e\\u02c6(x4)\\n    int256 constant x5 = 400000000000000000000; //2\\u02c62\\n    int256 constant a5 = 5459815003314423907810; //e\\u02c6(x5)\\n    int256 constant x6 = 200000000000000000000; //2\\u02c61\\n    int256 constant a6 = 738905609893065022723; //e\\u02c6(x6)\\n    int256 constant x7 = 100000000000000000000; //2\\u02c60\\n    int256 constant a7 = 271828182845904523536; //e\\u02c6(x7)\\n    int256 constant x8 = 50000000000000000000; //2\\u02c6-1\\n    int256 constant a8 = 164872127070012814685; //e\\u02c6(x8)\\n    int256 constant x9 = 25000000000000000000; //2\\u02c6-2\\n    int256 constant a9 = 128402541668774148407; //e\\u02c6(x9)\\n    int256 constant x10 = 12500000000000000000; //2\\u02c6-3\\n    int256 constant a10 = 113314845306682631683; //e\\u02c6(x10)\\n    int256 constant x11 = 6250000000000000000; //2\\u02c6-4\\n    int256 constant a11 = 106449445891785942956; //e\\u02c6(x11)\\n\\n    /**\\n     * Calculate the natural exponentiation of a number with 18 decimals precision.\\n     * @param x Exponent with 18 decimal places.\\n     * @notice Max x is log((2^255 - 1) / 10^20) = 130.700829182905140221\\n     * @notice Min x log(0.000000000000000001) = -41.446531673892822312\\n     * @return e\\u02c6x\\n     */\\n    function n_exp(int256 x) internal pure returns (int256) {\\n        _require(x >= EXPONENT_LB && x <= EXPONENT_UB, Errors.OUT_OF_BOUNDS);\\n\\n        if (x < 0) return (DOUBLE_DECIMALS / n_exp(-x));\\n        int256 ans = PRECISION;\\n        int256 last = 1;\\n        if (x >= x0) {\\n            last = a0;\\n            x -= x0;\\n        }\\n        if (x >= x1) {\\n            last *= a1;\\n            x -= x1;\\n        }\\n        x *= 100;\\n        if (x >= x2) {\\n            ans = (ans * a2) / PRECISION;\\n            x -= x2;\\n        }\\n        if (x >= x3) {\\n            ans = (ans * a3) / PRECISION;\\n            x -= x3;\\n        }\\n        if (x >= x4) {\\n            ans = (ans * a4) / PRECISION;\\n            x -= x4;\\n        }\\n        if (x >= x5) {\\n            ans = (ans * a5) / PRECISION;\\n            x -= x5;\\n        }\\n        if (x >= x6) {\\n            ans = (ans * a6) / PRECISION;\\n            x -= x6;\\n        }\\n        if (x >= x7) {\\n            ans = (ans * a7) / PRECISION;\\n            x -= x7;\\n        }\\n        if (x >= x8) {\\n            ans = (ans * a8) / PRECISION;\\n            x -= x8;\\n        }\\n        if (x >= x9) {\\n            ans = (ans * a9) / PRECISION;\\n            x -= x9;\\n        }\\n        int256 s = PRECISION;\\n        int256 t = x;\\n        s += t;\\n        t = ((t * x) / 2) / PRECISION;\\n        s += t;\\n        t = ((t * x) / 3) / PRECISION;\\n        s += t;\\n        t = ((t * x) / 4) / PRECISION;\\n        s += t;\\n        t = ((t * x) / 5) / PRECISION;\\n        s += t;\\n        t = ((t * x) / 6) / PRECISION;\\n        s += t;\\n        t = ((t * x) / 7) / PRECISION;\\n        s += t;\\n        t = ((t * x) / 8) / PRECISION;\\n        s += t;\\n        t = ((t * x) / 9) / PRECISION;\\n        s += t;\\n        t = ((t * x) / 10) / PRECISION;\\n        s += t;\\n        t = ((t * x) / 11) / PRECISION;\\n        s += t;\\n        t = ((t * x) / 12) / PRECISION;\\n        s += t;\\n        return (((ans * s) / PRECISION) * last) / 100;\\n    }\\n\\n    /**\\n     * Calculate the natural logarithm of a number with 18 decimals precision.\\n     * @param a Positive number with 18 decimal places.\\n     * @return ln(x)\\n     */\\n    function n_log(int256 a) internal pure returns (int256) {\\n        _require(a > 0, Errors.OUT_OF_BOUNDS);\\n        if (a < DECIMALS) return (-n_log(DOUBLE_DECIMALS / a));\\n        int256 ans = 0;\\n        if (a >= a0 * DECIMALS) {\\n            ans += x0;\\n            a /= a0;\\n        }\\n        if (a >= a1 * DECIMALS) {\\n            ans += x1;\\n            a /= a1;\\n        }\\n        a *= 100;\\n        ans *= 100;\\n        if (a >= a2) {\\n            ans += x2;\\n            a = (a * PRECISION) / a2;\\n        }\\n        if (a >= a3) {\\n            ans += x3;\\n            a = (a * PRECISION) / a3;\\n        }\\n        if (a >= a4) {\\n            ans += x4;\\n            a = (a * PRECISION) / a4;\\n        }\\n        if (a >= a5) {\\n            ans += x5;\\n            a = (a * PRECISION) / a5;\\n        }\\n        if (a >= a6) {\\n            ans += x6;\\n            a = (a * PRECISION) / a6;\\n        }\\n        if (a >= a7) {\\n            ans += x7;\\n            a = (a * PRECISION) / a7;\\n        }\\n        if (a >= a8) {\\n            ans += x8;\\n            a = (a * PRECISION) / a8;\\n        }\\n        if (a >= a9) {\\n            ans += x9;\\n            a = (a * PRECISION) / a9;\\n        }\\n        if (a >= a10) {\\n            ans += x10;\\n            a = (a * PRECISION) / a10;\\n        }\\n        if (a >= a11) {\\n            ans += x11;\\n            a = (a * PRECISION) / a11;\\n        }\\n        int256 z = (PRECISION * (a - PRECISION)) / (a + PRECISION);\\n        int256 s = z;\\n        int256 z_squared = (z * z) / PRECISION;\\n        int256 t = (z * z_squared) / PRECISION;\\n        s += t / 3;\\n        t = (t * z_squared) / PRECISION;\\n        s += t / 5;\\n        t = (t * z_squared) / PRECISION;\\n        s += t / 7;\\n        t = (t * z_squared) / PRECISION;\\n        s += t / 9;\\n        t = (t * z_squared) / PRECISION;\\n        s += t / 11;\\n        return (ans + 2 * s) / 100;\\n    }\\n\\n    /**\\n     * Computes x to the power of y for numbers with 18 decimals precision.\\n     * @param x Base with 18 decimal places.\\n     * @param y Exponent with 18 decimal places.\\n     * @notice Must fulfil: -41.446531673892822312  < (log(x) * y) <  130.700829182905140221\\n     * @return x\\u02c6y\\n     */\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\\n        if (y == 0) {\\n            return uint256(DECIMALS);\\n        }\\n\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        _require(x < 2**255, Errors.X_OUT_OF_BOUNDS); // uint256 can be casted to a positive int256\\n        _require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);\\n        int256 x_int256 = int256(x);\\n        int256 y_int256 = int256(y);\\n        int256 logx_times_y;\\n        if (PRECISION_LOG_UNDER_BOUND < x_int256 && x_int256 < PRECISION_LOG_UPPER_BOUND) {\\n            int256 logbase = n_log_36(x_int256);\\n            logx_times_y = ((logbase / DECIMALS) * y_int256 + ((logbase % DECIMALS) * y_int256) / DECIMALS);\\n        } else {\\n            logx_times_y = n_log(x_int256) * y_int256;\\n        }\\n        _require(\\n            EXPONENT_LB * DECIMALS <= logx_times_y && logx_times_y <= EXPONENT_UB * DECIMALS,\\n            Errors.PRODUCT_OUT_OF_BOUNDS\\n        );\\n        logx_times_y /= DECIMALS;\\n        return uint256(n_exp(logx_times_y));\\n    }\\n\\n    /**\\n     * Computes log of a number in base of another number, both numbers with 18 decimals precision.\\n     * @param arg Argument with 18 decimal places.\\n     * @param base Base with 18 decimal places.\\n     * @notice Must fulfil: -41.446531673892822312  < (log(x) * y) <  130.700829182905140221\\n     * @return log[base](arg)\\n     */\\n    function log(int256 arg, int256 base) internal pure returns (int256) {\\n        int256 logbase;\\n        if (PRECISION_LOG_UNDER_BOUND < base && base < PRECISION_LOG_UPPER_BOUND) {\\n            logbase = n_log_36(base);\\n        } else {\\n            logbase = n_log(base) * DECIMALS;\\n        }\\n        int256 logarg;\\n        if (PRECISION_LOG_UNDER_BOUND < arg && arg < PRECISION_LOG_UPPER_BOUND) {\\n            logarg = n_log_36(arg);\\n        } else {\\n            logarg = n_log(arg) * DECIMALS;\\n        }\\n        return (logarg * DECIMALS) / logbase;\\n    }\\n\\n    /**\\n     * Private function to calculate the natural logarithm of a number with 36 decimals precision.\\n     * @param a Positive number with 18 decimal places.\\n     * @return ln(x)\\n     */\\n    function n_log_36(int256 a) private pure returns (int256) {\\n        a *= DECIMALS;\\n        int256 z = (DOUBLE_DECIMALS * (a - DOUBLE_DECIMALS)) / (a + DOUBLE_DECIMALS);\\n        int256 s = z;\\n        int256 z_squared = (z * z) / DOUBLE_DECIMALS;\\n        int256 t = (z * z_squared) / DOUBLE_DECIMALS;\\n        s += t / 3;\\n        t = (t * z_squared) / DOUBLE_DECIMALS;\\n        s += t / 5;\\n        t = (t * z_squared) / DOUBLE_DECIMALS;\\n        s += t / 7;\\n        t = (t * z_squared) / DOUBLE_DECIMALS;\\n        s += t / 9;\\n        t = (t * z_squared) / DOUBLE_DECIMALS;\\n        s += t / 11;\\n        t = (t * z_squared) / DOUBLE_DECIMALS;\\n        s += t / 13;\\n        t = (t * z_squared) / DOUBLE_DECIMALS;\\n        s += t / 15;\\n        return 2 * s;\\n    }\\n}\\n\",\"keccak256\":\"0x436e3c7fbf448b7f6f434093360f346965eff106a7440315654c8c9877c62666\",\"license\":\"GPL-3.0-or-later\"},\"contracts/lib/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow checks.\\n * Adapted from OpenZeppelin's SafeMath library\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the addition of two unsigned integers of 256 bits, reverting on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        _require(c >= a, Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        _require((b >= 0 && c >= a) || (b < 0 && c < a), Errors.ADD_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers of 256 bits, reverting on overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b <= a, Errors.SUB_OVERFLOW);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        _require((b >= 0 && c <= a) || (b < 0 && c > a), Errors.SUB_OVERFLOW);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers of 256 bits.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers of 256 bits.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a * b;\\n        _require(a == 0 || c / a == b, Errors.MUL_OVERFLOW);\\n        return c;\\n    }\\n\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n        return a / b;\\n    }\\n\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        _require(b != 0, Errors.ZERO_DIVISION);\\n\\n        if (a == 0) {\\n            return 0;\\n        } else {\\n            return 1 + (a - 1) / b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x98cf5d1e9b91be5a4315c1aa7bf6480e097113c5f9a9200c92d123bc4ece9ec4\",\"license\":\"MIT\"},\"contracts/lib/openzeppelin/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            msg.sender,\\n            _allowances[sender][msg.sender].sub(amount, Errors.ERC20_TRANSFER_EXCEEDS_ALLOWANCE)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(\\n            msg.sender,\\n            spender,\\n            _allowances[msg.sender][spender].sub(subtractedValue, Errors.ERC20_DECREASED_ALLOWANCE_BELOW_ZERO)\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        _require(sender != address(0), Errors.ERC20_TRANSFER_FROM_ZERO_ADDRESS);\\n        _require(recipient != address(0), Errors.ERC20_TRANSFER_TO_ZERO_ADDRESS);\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, Errors.ERC20_TRANSFER_EXCEEDS_BALANCE);\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        _require(account != address(0), Errors.ERC20_MINT_TO_ZERO_ADDRESS);\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        _require(account != address(0), Errors.ERC20_BURN_FROM_ZERO_ADDRESS);\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, Errors.ERC20_BURN_EXCEEDS_ALLOWANCE);\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        _require(owner != address(0), Errors.ERC20_APPROVE_FROM_ZERO_ADDRESS);\\n        _require(spender != address(0), Errors.ERC20_APPROVE_TO_ZERO_ADDRESS);\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0xc9f3532224810392b608d6b65b0265a89cc674c8ec2c1c2ff55c727622e5f80b\",\"license\":\"MIT\"},\"contracts/lib/openzeppelin/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\n// Based on the ReentrancyGuard library from OpenZeppelin contracts, altered to reduce bytecode size.\\n// Modifier code is inlined by the compiler, which causes its code to appear multiple times in the codebase. By using\\n// private functions, we achieve the same end result with slightly higher runtime gas costs but reduced bytecode size.\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _enterNonReentrant();\\n        _;\\n        _exitNonReentrant();\\n    }\\n\\n    function _enterNonReentrant() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        _require(_status != _ENTERED, Errors.REENTRANCY);\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _exitNonReentrant() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0xe055f8c5d34af6e615892acf192c74d2d83784713bd98b2f8e44751f5ffe2bed\",\"license\":\"MIT\"},\"contracts/lib/openzeppelin/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(address(token), abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     *\\n     * WARNING: `token` is assumed to be a contract: calls to EOAs will *not* revert.\\n     */\\n    function _callOptionalReturn(address token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n        (bool success, bytes memory returndata) = token.call(data);\\n\\n        // If the low-level call didn't succeed we return whatever was returned from it.\\n        assembly {\\n            if eq(success, 0) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        // Finally we check the returndata size is either zero or true - note that this check will always pass for EOAs\\n        _require(returndata.length == 0 || abi.decode(returndata, (bool)), Errors.SAFE_ERC20_CALL_FAILED);\\n    }\\n}\\n\",\"keccak256\":\"0xde794bff40e00000584b5f95699ed325342c90884fa78698051b3b1427ccfd04\",\"license\":\"MIT\"},\"contracts/lib/openzeppelin/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../helpers/BalancerErrors.sol\\\";\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        _require(c >= a, Errors.ADD_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, Errors.SUB_OVERFLOW);\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, uint256 errorCode) internal pure returns (uint256) {\\n        _require(b <= a, errorCode);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        _require(c / a == b, Errors.MUL_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, Errors.ZERO_DIVISION);\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, uint256 errorCode) internal pure returns (uint256) {\\n        _require(b > 0, errorCode);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, Errors.ZERO_MOD);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, uint256 errorCode) internal pure returns (uint256) {\\n        _require(b != 0, errorCode);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xeb47c4b160ef64a04008737508dc5039ae7e4eff7a8b873b09ac14d908bd345d\",\"license\":\"MIT\"},\"contracts/pools/BalancerPoolToken.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../lib/math/Math.sol\\\";\\n\\n/**\\n * @title Highly opinionated token implementation\\n * @author Balancer Labs\\n * @dev\\n * - Includes functions to increase and decrease allowance as a workaround\\n *   for the well-known issue with `approve`:\\n *   https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n * - Allows for 'infinite allowance', where an allowance of 0xff..ff is not\\n *   decreased by calls to transferFrom\\n * - Lets a token holder use `transferFrom` to send their own tokens,\\n *   without first setting allowance\\n * - Emits 'Approval' events whenever allowance is changed by `transferFrom`\\n */\\ncontract BalancerPoolToken is IERC20 {\\n    using Math for uint256;\\n\\n    // State variables\\n\\n    uint8 private constant _DECIMALS = 18;\\n\\n    mapping(address => uint256) private _balance;\\n    mapping(address => mapping(address => uint256)) private _allowance;\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    // Function declarations\\n\\n    constructor(string memory tokenName, string memory tokenSymbol) {\\n        _name = tokenName;\\n        _symbol = tokenSymbol;\\n    }\\n\\n    // External functions\\n\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\n        return _allowance[owner][spender];\\n    }\\n\\n    function balanceOf(address account) external view override returns (uint256) {\\n        return _balance[account];\\n    }\\n\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        _setAllowance(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function increaseApproval(address spender, uint256 amount) external returns (bool) {\\n        _setAllowance(msg.sender, spender, _allowance[msg.sender][spender].add(amount));\\n\\n        return true;\\n    }\\n\\n    function decreaseApproval(address spender, uint256 amount) external returns (bool) {\\n        uint256 currentAllowance = _allowance[msg.sender][spender];\\n\\n        if (amount >= currentAllowance) {\\n            _setAllowance(msg.sender, spender, 0);\\n        } else {\\n            _setAllowance(msg.sender, spender, currentAllowance.sub(amount));\\n        }\\n\\n        return true;\\n    }\\n\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\n        _move(msg.sender, recipient, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        uint256 currentAllowance = _allowance[sender][msg.sender];\\n        _require(msg.sender == sender || currentAllowance >= amount, Errors.INSUFFICIENT_ALLOWANCE);\\n\\n        _move(sender, recipient, amount);\\n\\n        if (msg.sender != sender && currentAllowance != uint256(-1)) {\\n            // Because of the previous require, we know that if msg.sender != sender then currentAllowance >= amount\\n            _setAllowance(sender, msg.sender, currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    // Public functions\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public pure returns (uint8) {\\n        return _DECIMALS;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    // Internal functions\\n\\n    function _mintPoolTokens(address recipient, uint256 amount) internal {\\n        _balance[recipient] = _balance[recipient].add(amount);\\n        _totalSupply = _totalSupply.add(amount);\\n        emit Transfer(address(0), recipient, amount);\\n    }\\n\\n    function _burnPoolTokens(address sender, uint256 amount) internal {\\n        uint256 currentBalance = _balance[sender];\\n        _require(currentBalance >= amount, Errors.INSUFFICIENT_BALANCE);\\n\\n        _balance[sender] = currentBalance - amount;\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(sender, address(0), amount);\\n    }\\n\\n    function _move(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        uint256 currentBalance = _balance[sender];\\n        _require(currentBalance >= amount, Errors.INSUFFICIENT_BALANCE);\\n        // Prohibit transfers to the zero address to avoid confusion with the\\n        // Transfer event emitted by `_burnPoolTokens`\\n        _require(recipient != address(0), Errors.ERC20_TRANSFER_TO_ZERO_ADDRESS);\\n\\n        _balance[sender] = currentBalance - amount;\\n        _balance[recipient] = _balance[recipient].add(amount);\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    // Private functions\\n\\n    function _setAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) private {\\n        _allowance[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n}\\n\",\"keccak256\":\"0x6f24794729fb2524efae8fa4e657b657303a79e2d8dcbf44d4c6d44f0eeb6c3c\",\"license\":\"GPL-3.0-or-later\"},\"contracts/pools/BasePool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../lib/math/FixedPoint.sol\\\";\\nimport \\\"../lib/helpers/InputHelpers.sol\\\";\\nimport \\\"../lib/helpers/EmergencyPeriod.sol\\\";\\nimport \\\"../lib/openzeppelin/ERC20.sol\\\";\\n\\nimport \\\"./BalancerPoolToken.sol\\\";\\nimport \\\"./BasePoolAuthorization.sol\\\";\\nimport \\\"../vault/interfaces/IVault.sol\\\";\\nimport \\\"../vault/interfaces/IBasePool.sol\\\";\\n\\n// This contract relies on tons of immutable state variables to perform efficient lookup, without resorting to storage\\n// reads. Because immutable arrays are not supported, we instead declare a fixed set of state variables plus a total\\n// count, resulting in a large number of state variables.\\n\\n// solhint-disable max-states-count\\n\\n/**\\n * @dev Reference implementation for the base layer of a Pool contract that manages a single Pool with an immutable set\\n * of registered tokens, no Asset Managers, an admin-controlled swap fee, and an emergency stop mechanisms.\\n *\\n * Note that neither swap fees nor the emergency stop mechanism are used by this contract. They are passed through so\\n * that derived contracts can use them via the `_addSwapFee` and `_subtractSwapFee` functions, and the\\n * `noEmergencyPeriod` modifier.\\n *\\n * No admin permissions are checked here: instead, this contract delegates that to the Vault's own Authorizer.\\n *\\n * Because this contract doesn't implement the swap hooks, derived contracts should generally inherit from\\n * BaseGeneralPool or BaseMinimalSwapInfoPool. Otherwise, subclasses must inherit from the corresponding interfaces\\n * and implement the swap callbacks themselves.\\n */\\nabstract contract BasePool is IBasePool, BasePoolAuthorization, BalancerPoolToken, EmergencyPeriod {\\n    using FixedPoint for uint256;\\n\\n    uint256 private constant _MIN_TOKENS = 2;\\n    uint256 private constant _MAX_TOKENS = 8;\\n\\n    // 1e18 corresponds to 1.0, or a 100% fee\\n    uint256 private constant _MIN_SWAP_FEE = 1e12; // 0.0001%\\n    uint256 private constant _MAX_SWAP_FEE = 1e17; // 10%\\n\\n    uint256 private constant _MINIMUM_BPT = 10**6;\\n\\n    uint256 internal _swapFee;\\n\\n    IVault private immutable _vault;\\n    bytes32 private immutable _poolId;\\n    uint256 private immutable _totalTokens;\\n\\n    IERC20 internal immutable _token0;\\n    IERC20 internal immutable _token1;\\n    IERC20 internal immutable _token2;\\n    IERC20 internal immutable _token3;\\n    IERC20 internal immutable _token4;\\n    IERC20 internal immutable _token5;\\n    IERC20 internal immutable _token6;\\n    IERC20 internal immutable _token7;\\n\\n    // All token balances are normalized to behave as if the token had 18 decimals. We assume a token's decimals will\\n    // not change throughout its lifetime, and store the corresponding scaling factor for each at construction time.\\n    // These factors are always greater than or equal to one: tokens with more than 18 decimals are not supported.\\n\\n    uint256 internal immutable _scalingFactor0;\\n    uint256 internal immutable _scalingFactor1;\\n    uint256 internal immutable _scalingFactor2;\\n    uint256 internal immutable _scalingFactor3;\\n    uint256 internal immutable _scalingFactor4;\\n    uint256 internal immutable _scalingFactor5;\\n    uint256 internal immutable _scalingFactor6;\\n    uint256 internal immutable _scalingFactor7;\\n\\n    event SwapFeeChanged(uint256 swapFee);\\n\\n    constructor(\\n        IVault vault,\\n        IVault.PoolSpecialization specialization,\\n        string memory name,\\n        string memory symbol,\\n        IERC20[] memory tokens,\\n        uint256 swapFee,\\n        uint256 emergencyPeriod,\\n        uint256 emergencyPeriodCheckExtension\\n    ) BalancerPoolToken(name, symbol) EmergencyPeriod(emergencyPeriod, emergencyPeriodCheckExtension) {\\n        _require(tokens.length >= _MIN_TOKENS, Errors.MIN_TOKENS);\\n        _require(tokens.length <= _MAX_TOKENS, Errors.MAX_TOKENS);\\n\\n        // The Vault only requires the token list to be ordered for the Two Token Pools specialization. However,\\n        // to make the developer experience consistent, we are requiring this condition for all the native pools.\\n        // Also, since these Pools will register tokens only once, we can ensure the Pool tokens will follow the same\\n        // order. We rely on this property to make Pools simpler to write, as it lets us assume that the\\n        // order of token-specific parameters (such as token weights) will not change.\\n        InputHelpers.ensureArrayIsSorted(tokens);\\n\\n        _require(swapFee >= _MIN_SWAP_FEE, Errors.MIN_SWAP_FEE);\\n        _require(swapFee <= _MAX_SWAP_FEE, Errors.MAX_SWAP_FEE);\\n\\n        bytes32 poolId = vault.registerPool(specialization);\\n\\n        // Pass in zero addresses for Asset Managers\\n        vault.registerTokens(poolId, tokens, new address[](tokens.length));\\n\\n        // Set immutable state variables - these cannot be read from during construction\\n\\n        _vault = vault;\\n        _poolId = poolId;\\n        _swapFee = swapFee;\\n        _totalTokens = tokens.length;\\n\\n        // Immutable variables cannot be initialized inside an if statement, so we must do conditional assignments\\n\\n        _token0 = tokens.length > 0 ? tokens[0] : IERC20(0);\\n        _token1 = tokens.length > 1 ? tokens[1] : IERC20(0);\\n        _token2 = tokens.length > 2 ? tokens[2] : IERC20(0);\\n        _token3 = tokens.length > 3 ? tokens[3] : IERC20(0);\\n        _token4 = tokens.length > 4 ? tokens[4] : IERC20(0);\\n        _token5 = tokens.length > 5 ? tokens[5] : IERC20(0);\\n        _token6 = tokens.length > 6 ? tokens[6] : IERC20(0);\\n        _token7 = tokens.length > 7 ? tokens[7] : IERC20(0);\\n\\n        _scalingFactor0 = tokens.length > 0 ? _computeScalingFactor(tokens[0]) : 0;\\n        _scalingFactor1 = tokens.length > 1 ? _computeScalingFactor(tokens[1]) : 0;\\n        _scalingFactor2 = tokens.length > 2 ? _computeScalingFactor(tokens[2]) : 0;\\n        _scalingFactor3 = tokens.length > 3 ? _computeScalingFactor(tokens[3]) : 0;\\n        _scalingFactor4 = tokens.length > 4 ? _computeScalingFactor(tokens[4]) : 0;\\n        _scalingFactor5 = tokens.length > 5 ? _computeScalingFactor(tokens[5]) : 0;\\n        _scalingFactor6 = tokens.length > 6 ? _computeScalingFactor(tokens[6]) : 0;\\n        _scalingFactor7 = tokens.length > 7 ? _computeScalingFactor(tokens[7]) : 0;\\n    }\\n\\n    // Getters / Setters\\n\\n    function getVault() external view returns (IVault) {\\n        return _getVault();\\n    }\\n\\n    function _getVault() internal view returns (IVault) {\\n        return _vault;\\n    }\\n\\n    function getPoolId() external view returns (bytes32) {\\n        return _getPoolId();\\n    }\\n\\n    function _getPoolId() internal view returns (bytes32) {\\n        return _poolId;\\n    }\\n\\n    function _getTotalTokens() internal view returns (uint256) {\\n        return _totalTokens;\\n    }\\n\\n    function getSwapFee() external view returns (uint256) {\\n        return _swapFee;\\n    }\\n\\n    // Caller must be approved by the Vault's Authorizer\\n    function setSwapFee(uint256 swapFee) external virtual authenticate {\\n        _require(swapFee >= _MIN_SWAP_FEE, Errors.MIN_SWAP_FEE);\\n        _require(swapFee <= _MAX_SWAP_FEE, Errors.MAX_SWAP_FEE);\\n\\n        _swapFee = swapFee;\\n        emit SwapFeeChanged(swapFee);\\n    }\\n\\n    // Caller must be approved by the Vault's Authorizer\\n    function setEmergencyPeriod(bool active) external authenticate {\\n        _setEmergencyPeriod(active);\\n    }\\n\\n    // Join / Exit Hooks\\n\\n    modifier onlyVault(bytes32 poolId) {\\n        _require(msg.sender == address(_getVault()), Errors.CALLER_NOT_VAULT);\\n        _require(poolId == _getPoolId(), Errors.INVALID_POOL_ID);\\n        _;\\n    }\\n\\n    function onJoinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory currentBalances,\\n        uint256 latestBlockNumberUsed,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) external virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\\n        uint256[] memory scalingFactors = _scalingFactors();\\n\\n        if (totalSupply() == 0) {\\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(poolId, sender, recipient, userData);\\n\\n            // On initialization, we lock _MINIMUM_BPT by minting it for the zero address. This BPT acts as a minimum\\n            // as it will never be burned, which reduces potential issues with rounding, and also prevents the Pool from\\n            // ever being fully drained.\\n            _require(bptAmountOut >= _MINIMUM_BPT, Errors.MINIMUM_BPT);\\n            _mintPoolTokens(address(0), _MINIMUM_BPT);\\n            _mintPoolTokens(recipient, bptAmountOut - _MINIMUM_BPT);\\n\\n            // amountsIn are amounts entering the Pool, so we round up.\\n            _downscaleUpArray(amountsIn, scalingFactors);\\n\\n            return (amountsIn, new uint256[](_getTotalTokens()));\\n        } else {\\n            _upscaleArray(currentBalances, scalingFactors);\\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\\n                poolId,\\n                sender,\\n                recipient,\\n                currentBalances,\\n                latestBlockNumberUsed,\\n                protocolSwapFeePercentage,\\n                userData\\n            );\\n\\n            // Note we no longer use `currentBalances` after calling `_onJoinPool`, which may mutate it.\\n\\n            _mintPoolTokens(recipient, bptAmountOut);\\n\\n            // amountsIn are amounts entering the Pool, so we round up.\\n            _downscaleUpArray(amountsIn, scalingFactors);\\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\\n\\n            return (amountsIn, dueProtocolFeeAmounts);\\n        }\\n    }\\n\\n    function onExitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory currentBalances,\\n        uint256 latestBlockNumberUsed,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) external virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\\n        uint256[] memory scalingFactors = _scalingFactors();\\n        _upscaleArray(currentBalances, scalingFactors);\\n\\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\\n            poolId,\\n            sender,\\n            recipient,\\n            currentBalances,\\n            latestBlockNumberUsed,\\n            protocolSwapFeePercentage,\\n            userData\\n        );\\n\\n        // Note we no longer use `currentBalances` after calling `_onExitPool`, which may mutate it.\\n\\n        _burnPoolTokens(sender, bptAmountIn);\\n\\n        // Both amountsOut and dueProtocolFees are amounts exiting the Pool, so we round down.\\n        _downscaleDownArray(amountsOut, scalingFactors);\\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\\n\\n        return (amountsOut, dueProtocolFeeAmounts);\\n    }\\n\\n    // Query functions\\n\\n    /**\\n     * @dev Returns the amount of BPT that would be granted to `recipient` if the `onJoinPool` hook were called by the\\n     * Vault with the the same arguments, along with the number of tokens `sender` would have to supply.\\n     *\\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\\n     * data, such as the protocol swap fee and Pool balances.\\n     *\\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\\n     * explicitly use eth_call instead of eth_sendTransaction.\\n     */\\n    function queryJoin(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory currentBalances,\\n        uint256 latestBlockNumberUsed,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\\n        return\\n            _queryAction(\\n                poolId,\\n                sender,\\n                recipient,\\n                currentBalances,\\n                latestBlockNumberUsed,\\n                protocolSwapFeePercentage,\\n                userData,\\n                _onJoinPool,\\n                _downscaleUpArray\\n            );\\n    }\\n\\n    /**\\n     * @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the\\n     * Vault with the the same arguments, along with the number of tokens `recipient` would receive.\\n     *\\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\\n     * data, such as the protocol swap fee and Pool balances.\\n     *\\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\\n     * explicitly use eth_call instead of eth_sendTransaction.\\n     */\\n    function queryExit(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory currentBalances,\\n        uint256 latestBlockNumberUsed,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\\n        return\\n            _queryAction(\\n                poolId,\\n                sender,\\n                recipient,\\n                currentBalances,\\n                latestBlockNumberUsed,\\n                protocolSwapFeePercentage,\\n                userData,\\n                _onExitPool,\\n                _downscaleDownArray\\n            );\\n    }\\n\\n    // Internal hooks to be overridden by derived contracts - all token amounts (except BPT) in these interfaces are\\n    // upscaled.\\n\\n    /**\\n     * @dev Called when the Pool is joined for the first time; that is, when the BPT total supply is zero.\\n     *\\n     * Returns the amount of BPT to mint, and the token amounts the Pool will receive in return.\\n     *\\n     * Minted BPT will be sent to `recipient`, except for _MINIMUM_BPT, which will be deducted from this amount and sent\\n     * to the zero address instead. This will cause that BPT to remain forever locked there, preventing total BTP from\\n     * ever dropping below that value, and ensuring `_onInitializePool` can only be called once in the entire Pool's\\n     * lifetime.\\n     *\\n     * The tokens granted to the Pool will be transferred from `sender`. These amounts are considered upscaled and will\\n     * be downscaled (rounding up) before being returned to the Vault.\\n     */\\n    function _onInitializePool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        bytes memory userData\\n    ) internal virtual returns (uint256 bptAmountOut, uint256[] memory amountsIn);\\n\\n    /**\\n     * @dev Called whenever the Pool is joined after the first initialization join (see `_onInitializePool`).\\n     *\\n     * Returns the amount of BPT to mint, the token amounts that the Pool will receive in return, and the number of\\n     * tokens to pay in protocol swap fees.\\n     *\\n     * Implementations of this function might choose to mutate the `currentBalances` array to save gas (e.g. when\\n     * performing intermediate calculations, such as subtraction of due protocol fees). This can be done safely.\\n     *\\n     * Minted BPT will be sent to `recipient`.\\n     *\\n     * The tokens granted to the Pool will be transferred from `sender`. These amounts are considered upscaled and will\\n     * be downscaled (rounding up) before being returned to the Vault.\\n     *\\n     * Due protocol swap fees will be taken from the Pool's balance in the Vault (see `IBasePool.onJoinPool`). These\\n     * amounts are considered upscaled and will be downscaled (rounding down) before being returned to the Vault.\\n     */\\n    function _onJoinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory currentBalances,\\n        uint256 latestBlockNumberUsed,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    )\\n        internal\\n        virtual\\n        returns (\\n            uint256 bptAmountOut,\\n            uint256[] memory amountsIn,\\n            uint256[] memory dueProtocolFeeAmounts\\n        );\\n\\n    /**\\n     * @dev Called whenever the Pool is exited.\\n     *\\n     * Returns the amount of BPT to burn, the token amounts for each Pool token that the Pool will grant in return, and\\n     * the number of tokens to pay in protocol swap fees.\\n     *\\n     * Implementations of this function might choose to mutate the `currentBalances` array to save gas (e.g. when\\n     * performing intermediate calculations, such as subtraction of due protocol fees). This can be done safely.\\n     *\\n     * BPT will be burnt from `sender`.\\n     *\\n     * The Pool will grant tokens to `recipient`. These amounts are considered upscaled and will  be downscaled\\n     * (rounding down) before being returned to the Vault.\\n     *\\n     * Due protocol swap fees will be taken from the Pool's balance in the Vault (see `IBasePool.onExitPool`). These\\n     * amounts are considered upscaled and will be downscaled (rounding down) before being returned to the Vault.\\n     */\\n    function _onExitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory currentBalances,\\n        uint256 latestBlockNumberUsed,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData\\n    )\\n        internal\\n        virtual\\n        returns (\\n            uint256 bptAmountIn,\\n            uint256[] memory amountsOut,\\n            uint256[] memory dueProtocolFeeAmounts\\n        );\\n\\n    // Internal functions\\n\\n    /**\\n     * @dev Adds swap fees to `amount`, returning a larger value.\\n     */\\n    function _addSwapFee(uint256 amount) internal view returns (uint256) {\\n        // This returns amount + fees, so we round up (favoring fees).\\n        return amount.divUp(_swapFee.complement());\\n    }\\n\\n    /**\\n     * @dev Subtracts swap fees from `amount`, returning a lower value.\\n     */\\n    function _subtractSwapFee(uint256 amount) internal view returns (uint256) {\\n        // Round up, favoring fees.\\n        uint256 fees = amount.mulUp(_swapFee);\\n        return amount.sub(fees);\\n    }\\n\\n    // Scaling\\n\\n    /**\\n     * @dev Returns a scaling factor that, when multiplied to a token amount for `token`, normalizes its balance as if\\n     * it had 18 decimals.\\n     */\\n    function _computeScalingFactor(IERC20 token) private view returns (uint256) {\\n        // Tokens that don't implement the `decimals` method are not supported.\\n        uint256 tokenDecimals = ERC20(address(token)).decimals();\\n\\n        // Tokens with more than 18 decimals are not supported.\\n        uint256 decimalsDifference = Math.sub(18, tokenDecimals);\\n        return 10**decimalsDifference;\\n    }\\n\\n    /**\\n     * @dev Returns the scaling factor for one of the Pool's tokens. Reverts if `token` is not a token registered by the\\n     * Pool.\\n     */\\n    function _scalingFactor(IERC20 token) internal view returns (uint256) {\\n        // prettier-ignore\\n        if (token == _token0) { return _scalingFactor0; }\\n        else if (token == _token1) { return _scalingFactor1; }\\n        else if (token == _token2) { return _scalingFactor2; }\\n        else if (token == _token3) { return _scalingFactor3; }\\n        else if (token == _token4) { return _scalingFactor4; }\\n        else if (token == _token5) { return _scalingFactor5; }\\n        else if (token == _token6) { return _scalingFactor6; }\\n        else if (token == _token7) { return _scalingFactor7; }\\n        else {\\n            _revert(Errors.INVALID_TOKEN);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns all the scaling factors in the same order as the registered tokens. The Vault will always\\n     * pass balances in this order when calling any of the Pool hooks\\n     */\\n    function _scalingFactors() internal view returns (uint256[] memory) {\\n        uint256 totalTokens = _getTotalTokens();\\n        uint256[] memory scalingFactors = new uint256[](totalTokens);\\n\\n        // prettier-ignore\\n        {\\n            if (totalTokens > 0) { scalingFactors[0] = _scalingFactor0; } else { return scalingFactors; }\\n            if (totalTokens > 1) { scalingFactors[1] = _scalingFactor1; } else { return scalingFactors; }\\n            if (totalTokens > 2) { scalingFactors[2] = _scalingFactor2; } else { return scalingFactors; }\\n            if (totalTokens > 3) { scalingFactors[3] = _scalingFactor3; } else { return scalingFactors; }\\n            if (totalTokens > 4) { scalingFactors[4] = _scalingFactor4; } else { return scalingFactors; }\\n            if (totalTokens > 5) { scalingFactors[5] = _scalingFactor5; } else { return scalingFactors; }\\n            if (totalTokens > 6) { scalingFactors[6] = _scalingFactor6; } else { return scalingFactors; }\\n            if (totalTokens > 7) { scalingFactors[7] = _scalingFactor7; } else { return scalingFactors; }\\n        }\\n\\n        return scalingFactors;\\n    }\\n\\n    /**\\n     * @dev Applies `scalingFactor` to `amount`, resulting in a larger or equal value depending on whether it needed\\n     * scaling or not.\\n     */\\n    function _upscale(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\\n        return Math.mul(amount, scalingFactor);\\n    }\\n\\n    /**\\n     * @dev Same as `_upscale`, but for an entire array. This function does not return anything, but instead *mutates*\\n     * the `amounts` array.\\n     */\\n    function _upscaleArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            amounts[i] = Math.mul(amounts[i], scalingFactors[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on\\n     * whether it needed scaling or not. The result is rounded down.\\n     */\\n    function _downscaleDown(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\\n        return Math.divDown(amount, scalingFactor);\\n    }\\n\\n    /**\\n     * @dev Same as `_downscaleDown`, but for an entire array. This function does not return anything, but instead\\n     * *mutates* the `amounts` array.\\n     */\\n    function _downscaleDownArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            amounts[i] = Math.divDown(amounts[i], scalingFactors[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverses the `scalingFactor` applied to `amount`, resulting in a smaller or equal value depending on\\n     * whether it needed scaling or not. The result is rounded up.\\n     */\\n    function _downscaleUp(uint256 amount, uint256 scalingFactor) internal pure returns (uint256) {\\n        return Math.divUp(amount, scalingFactor);\\n    }\\n\\n    /**\\n     * @dev Same as `_downscaleUp`, but for an entire array. This function does not return anything, but instead\\n     * *mutates* the `amounts` array.\\n     */\\n    function _downscaleUpArray(uint256[] memory amounts, uint256[] memory scalingFactors) internal view {\\n        for (uint256 i = 0; i < _getTotalTokens(); ++i) {\\n            amounts[i] = Math.divUp(amounts[i], scalingFactors[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev This contract relies on the roles defined by the Vault's own Authorizer.\\n     */\\n    function _getAuthorizer() internal view override returns (IAuthorizer) {\\n        return _getVault().getAuthorizer();\\n    }\\n\\n    function _queryAction(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] memory currentBalances,\\n        uint256 latestBlockNumberUsed,\\n        uint256 protocolSwapFeePercentage,\\n        bytes memory userData,\\n        function(bytes32, address, address, uint256[] memory, uint256, uint256, bytes memory)\\n            internal\\n            returns (uint256, uint256[] memory, uint256[] memory) _action,\\n        function(uint256[] memory, uint256[] memory) internal view _downscaleArray\\n    ) private returns (uint256, uint256[] memory) {\\n        // This uses the same technique used by the Vault in queryBatchSwap. Refer to that function for a detailed\\n        // explanation.\\n\\n        if (msg.sender != address(this)) {\\n            // We perform an external call to ourselves, forwarding the same calldata. In this call, the else clause of\\n            // the preceding if statement will be executed instead.\\n\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, ) = address(this).call(msg.data);\\n\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                // This call should always revert to decode the bpt and token amounts from the revert reason\\n                switch success\\n                    case 0 {\\n                        // Note we are manually writing the memory slot 0. We can safely overwrite whatever is\\n                        // stored there as we take full control of the execution and then immediately return.\\n\\n                        // We copy the first 4 bytes to check if it matches with the expected signature, otherwise\\n                        // there was another revert reason and we should forward it.\\n                        returndatacopy(0, 0, 0x04)\\n                        let error := and(mload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\\n\\n                        // If the first 4 bytes don't match with the expected signature, we forward the revert reason.\\n                        if eq(eq(error, 0x43adbafb00000000000000000000000000000000000000000000000000000000), 0) {\\n                            returndatacopy(0, 0, returndatasize())\\n                            revert(0, returndatasize())\\n                        }\\n\\n                        // The returndata contains the signature, followed by the raw memory representation of the\\n                        // `bptAmount` and `tokenAmounts` (array: length + data). We need to return an ABI-encoded\\n                        // representation of these.\\n                        // An ABI-encoded response will include one additional field to indicate the starting offset of\\n                        // the `tokenAmounts` array. The `bptAmount` will be laid out in the first word of the\\n                        // returndata.\\n                        //\\n                        // In returndata:\\n                        // [ signature ][ bptAmount ][ tokenAmounts length ][ tokenAmounts values ]\\n                        // [  4 bytes  ][  32 bytes ][       32 bytes      ][ (32 * length) bytes ]\\n                        //\\n                        // We now need to return (ABI-encoded values):\\n                        // [ bptAmount ][ tokeAmounts offset ][ tokenAmounts length ][ tokenAmounts values ]\\n                        // [  32 bytes ][       32 bytes     ][       32 bytes      ][ (32 * length) bytes ]\\n\\n                        // We copy 32 bytes for the `bptAmount` from returndata into memory.\\n                        // Note that we skip the first 4 bytes for the error signature\\n                        returndatacopy(0, 0x04, 32)\\n\\n                        // The offsets are 32-bytes long, so the array of `tokenAmounts` will start after\\n                        // the initial 64 bytes.\\n                        mstore(0x20, 64)\\n\\n                        // We now copy the raw memory array for the `tokenAmounts` from returndata into memory.\\n                        // Since bpt amount and offset take up 64 bytes, we start copying at address 0x40. We also\\n                        // skip the first 36 bytes from returndata, which correspond to the signature plus bpt amount.\\n                        returndatacopy(0x40, 0x24, sub(returndatasize(), 36))\\n\\n                        // We finally return the ABI-encoded uint256 and the array, which has a total length equal to\\n                        // the size of returndata, plus the 32 bytes of the offset but without the 4 bytes of the\\n                        // error signature.\\n                        return(0, add(returndatasize(), 28))\\n                    }\\n                    default {\\n                        // This call should always revert, but we fail nonetheless if that didn't happen\\n                        invalid()\\n                    }\\n            }\\n        } else {\\n            uint256[] memory scalingFactors = _scalingFactors();\\n            _upscaleArray(currentBalances, scalingFactors);\\n\\n            (uint256 bptAmount, uint256[] memory tokenAmounts, ) = _action(\\n                poolId,\\n                sender,\\n                recipient,\\n                currentBalances,\\n                latestBlockNumberUsed,\\n                protocolSwapFeePercentage,\\n                userData\\n            );\\n\\n            _downscaleArray(tokenAmounts, scalingFactors);\\n\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                // We will return a raw representation of `bptAmount` and `tokenAmounts` in memory, which is composed of\\n                // a 32-byte uint256, followed by a 32-byte for the array length, and finally the 32-byte uint256 values\\n                // Because revert expects a size in bytes, we multiply the array length (stored at `tokenAmounts`) by 32\\n                let size := mul(mload(tokenAmounts), 32)\\n\\n                // We store the `bptAmount` in the previous slot to the `tokenAmounts` array. We can make sure there\\n                // will be at least one available slot due to how the memory scratch space works.\\n                // We can safely overwrite whatever is stored in this slot as we will revert immediately after that.\\n                let start := sub(tokenAmounts, 0x20)\\n                mstore(start, bptAmount)\\n\\n                // We send one extra value for the error signature \\\"QueryError(uint256,uint256[])\\\" which is 0x43adbafb\\n                // We use the previous slot to `bptAmount`.\\n                mstore(sub(start, 0x20), 0x0000000000000000000000000000000000000000000000000000000043adbafb)\\n                start := sub(start, 0x04)\\n\\n                // When copying from `tokenAmounts` into returndata, we copy the additional 68 bytes to also return\\n                // the `bptAmount`, the array 's length, and the error signature.\\n                revert(start, add(size, 68))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8527d417f016607833d21579073a538702597a2ee7bb7b35265f95722440b3a3\",\"license\":\"GPL-3.0-or-later\"},\"contracts/pools/BasePoolAuthorization.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../lib/helpers/Authentication.sol\\\";\\nimport \\\"../vault/interfaces/IAuthorizer.sol\\\";\\n\\n/**\\n * @dev Base authorization layer implementation for pools. It shares the same concept as the one defined for the Vault.\\n * It's built on top of OpenZeppelin's Access Control, which allows defining specific roles to control what access\\n * external accounts have to specific contract functions.\\n */\\nabstract contract BasePoolAuthorization is Authentication {\\n    function getAuthorizer() external view returns (IAuthorizer) {\\n        return _getAuthorizer();\\n    }\\n\\n    function _canPerform(bytes32 roleId, address account) internal view override returns (bool) {\\n        return _getAuthorizer().hasRole(roleId, account);\\n    }\\n\\n    function _getAuthorizer() internal view virtual returns (IAuthorizer);\\n}\\n\",\"keccak256\":\"0xfe21be915389160ff8835ae15f11d3494a4c64c1ab621204575da9cd83a1d6a6\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/ProtocolFeesCollector.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../lib/helpers/InputHelpers.sol\\\";\\nimport \\\"../lib/helpers/Authentication.sol\\\";\\nimport \\\"../lib/openzeppelin/ReentrancyGuard.sol\\\";\\nimport \\\"../lib/openzeppelin/SafeERC20.sol\\\";\\n\\nimport \\\"./interfaces/IVault.sol\\\";\\nimport \\\"./interfaces/IAuthorizer.sol\\\";\\n\\n/**\\n * @dev This an auxiliary contract to the Vault, deployed by it during construction. It offloads some of the tasks the\\n * Vault performs to reduce its overall bytecode size.\\n *\\n * The current values for all protocol fee percentages are stored here, and any protocol fees charged in the form of\\n * tokens are sent to this contract, where they may be withdrawn by authorized entities. All authorization tasks are\\n * delegated to the Vault's own authorizer.\\n */\\ncontract ProtocolFeesCollector is Authentication, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n\\n    // Absolute maximum fee percentages (1e18 = 100%, 1e16 = 1%).\\n    uint256 private constant _MAX_PROTOCOL_SWAP_FEE = 50e16; // 50%\\n    uint256 private constant _MAX_PROTOCOL_FLASH_LOAN_FEE = 1e16; // 1%\\n\\n    IVault public immutable vault;\\n\\n    // All fees are 18-decimal fixed point numbers.\\n\\n    // The swap fee is charged whenever a swap occurs, as a percentage of the fee charged by the Pool. These are not\\n    // actually charged on each individual swap: the `Vault` relies on the Pools being honest and reporting fees due\\n    // when users join and exit them.\\n    uint256 private _swapFee;\\n\\n    // The flash loan fee is charged whenever a flash loan occurs, as a percentage of the tokens lent.\\n    uint256 private _flashLoanFee;\\n\\n    event SwapFeeChanged(uint256 newSwapFee);\\n    event FlashLoanFeeChanged(uint256 newFlashLoanFee);\\n\\n    constructor(IVault _vault) {\\n        vault = _vault;\\n    }\\n\\n    function withdrawCollectedFees(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        address recipient\\n    ) external nonReentrant authenticate {\\n        InputHelpers.ensureInputLengthMatch(tokens.length, amounts.length);\\n\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            IERC20 token = tokens[i];\\n            uint256 amount = amounts[i];\\n            token.safeTransfer(recipient, amount);\\n        }\\n    }\\n\\n    function setSwapFee(uint256 newSwapFee) external authenticate {\\n        _require(newSwapFee <= _MAX_PROTOCOL_SWAP_FEE, Errors.SWAP_FEE_TOO_HIGH);\\n        _swapFee = newSwapFee;\\n        emit SwapFeeChanged(newSwapFee);\\n    }\\n\\n    function setFlashLoanFee(uint256 newFlashLoanFee) external authenticate {\\n        _require(newFlashLoanFee <= _MAX_PROTOCOL_FLASH_LOAN_FEE, Errors.FLASH_LOAN_FEE_TOO_HIGH);\\n        _flashLoanFee = newFlashLoanFee;\\n        emit FlashLoanFeeChanged(newFlashLoanFee);\\n    }\\n\\n    function getSwapFee() external view returns (uint256) {\\n        return _swapFee;\\n    }\\n\\n    function getFlashLoanFee() external view returns (uint256) {\\n        return _flashLoanFee;\\n    }\\n\\n    function getCollectedFees(IERC20[] memory tokens) external view returns (uint256[] memory fees) {\\n        fees = new uint256[](tokens.length);\\n        for (uint256 i = 0; i < tokens.length; ++i) {\\n            fees[i] = tokens[i].balanceOf(address(this));\\n        }\\n    }\\n\\n    function getAuthorizer() external view returns (IAuthorizer) {\\n        return _getAuthorizer();\\n    }\\n\\n    function _canPerform(bytes32 roleId, address account) internal view override returns (bool) {\\n        return _getAuthorizer().hasRole(roleId, account);\\n    }\\n\\n    function _getAuthorizer() internal view returns (IAuthorizer) {\\n        return vault.getAuthorizer();\\n    }\\n}\\n\",\"keccak256\":\"0xba35d5d6829d64eb3c632e0fe1321c4e6436c9ad2081e1b8a3799ec958c93775\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/balances/BalanceAllocation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../../lib/math/Math.sol\\\";\\n\\n// This library is used to create a data structure that represents a token's balance for a Pool. 'cash' is how many\\n// tokens the Pool has sitting inside of the Vault. 'managed' is how many tokens were withdrawn from the Vault by the\\n// Pool's Asset Manager. 'total' is the sum of these two, and represents the Pool's total token balance, including\\n// tokens that are *not* inside of the Vault.\\n//\\n// 'cash' is updated whenever tokens enter and exit the Vault, while 'managed' is only updated if the reason tokens are\\n// moving is due to an Asset Manager action. This is reflected in the different methods available: 'increaseCash'\\n// and 'decreaseCash' for swaps and add/remove liquidity events, and 'cashToManaged' and 'managedToCash' for\\n// events transferring funds to and from the asset manager.\\n//\\n// The Vault disallows the Pool's 'cash' ever becoming negative, in other words, it can never use any tokens that\\n// are not inside of the Vault.\\n//\\n// One of the goals of this library is to store the entire token balance in a single storage slot, which is why we use\\n// 112 bit unsigned integers for 'cash' and 'managed'. Since 'total' is also a 112 bit unsigned value, any combination\\n// of 'cash' and 'managed' that yields a 'total' that doesn't fit in that range is disallowed.\\n//\\n// The remaining 32 bits of each storage slot are used to store the most recent block number when a balance was\\n// updated. This can be used to implement price oracles that are resilient to 'sandwich' attacks.\\n//\\n// We could use a Solidity struct to pack these two values together in a single storage slot, but unfortunately Solidity\\n// only allows for structs to live in either storage, calldata or memory. Because a memory struct still takes up a\\n// slot in the stack (to store its memory location), and because the entire balance fits in a single stack slot (two\\n// 112 bit values), using memory is strictly less gas performant. Therefore, we do manual packing and unpacking. The\\n// type we use to represent these values is bytes32, as it doesn't have any arithmetic operations and therefore reduces\\n// the chance of misuse.\\nlibrary BalanceAllocation {\\n    using Math for uint256;\\n\\n    // The 'cash' portion of the balance is stored in the least significant 112 bits of a 256 bit word, while the\\n    // 'managed' part uses the following 112 bits. The remaining 32 bits are used to store the block number.\\n\\n    /**\\n     * @dev Returns the total amount of Pool tokens, including those that are not currently in the Vault ('managed').\\n     */\\n    function total(bytes32 balance) internal pure returns (uint256) {\\n        return cash(balance).add(managed(balance));\\n    }\\n\\n    /**\\n     * @dev Returns the amount of Pool tokens currently in the Vault.\\n     */\\n    function cash(bytes32 balance) internal pure returns (uint256) {\\n        uint256 mask = 2**(112) - 1;\\n        return uint256(balance) & mask;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of Pool tokens that have been withdrawn (or updated through setManaged)\\n     * by its Asset Manager.\\n     */\\n    function managed(bytes32 balance) internal pure returns (uint256) {\\n        uint256 mask = 2**(112) - 1;\\n        return uint256(balance >> 112) & mask;\\n    }\\n\\n    /**\\n     * @dev Returns the last block number when a balance was updated.\\n     */\\n    function blockNumber(bytes32 balance) internal pure returns (uint256) {\\n        uint256 mask = 2**(32) - 1;\\n        return uint256(balance >> 224) & mask;\\n    }\\n\\n    /**\\n     * @dev Returns the managed delta between two balances\\n     */\\n    function managedDelta(bytes32 balance, bytes32 otherBalance) internal pure returns (int256) {\\n        // Due to how balances are packed we know the delta between two managed values will always fit in an int256\\n        return int256(managed(balance)) - int256(managed(otherBalance));\\n    }\\n\\n    /**\\n     * @dev Returns the total balance for each entry in `balances`, as well as the latest block number when any of them\\n     * was last updated.\\n     */\\n    function totalsAndMaxBlockNumber(bytes32[] memory balances)\\n        internal\\n        pure\\n        returns (uint256[] memory results, uint256 maxBlockNumber)\\n    {\\n        maxBlockNumber = 0;\\n        results = new uint256[](balances.length);\\n\\n        for (uint256 i = 0; i < results.length; i++) {\\n            bytes32 balance = balances[i];\\n            results[i] = total(balance);\\n            maxBlockNumber = Math.max(maxBlockNumber, blockNumber(balance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if `balance`'s total balance is zero. Costs less gas than computing the total.\\n     */\\n    function isZero(bytes32 balance) internal pure returns (bool) {\\n        // We simply need to check the least significant 224 bytes of the word, the block number does not affect this.\\n        uint256 mask = 2**(224) - 1;\\n        return (uint256(balance) & mask) == 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if `balance`'s total balance is not zero. Costs less gas than computing the total.\\n     */\\n    function isNotZero(bytes32 balance) internal pure returns (bool) {\\n        return !isZero(balance);\\n    }\\n\\n    /**\\n     * @dev Packs together cash and managed amounts with a block number to create a balance value.\\n     * Critically, this also checks that the sum of cash and external doesn't overflow, that is, that `total()`\\n     * can be computed.\\n     */\\n    function toBalance(\\n        uint256 _cash,\\n        uint256 _managed,\\n        uint256 _blockNumber\\n    ) internal pure returns (bytes32) {\\n        uint256 balance = _cash + _managed;\\n        // We assume the block number will fit in a uint32 - this is expected to hold for at least a few decades.\\n        _require(balance >= _cash && balance < 2**112, Errors.BALANCE_TOTAL_OVERFLOW);\\n        return _pack(_cash, _managed, _blockNumber);\\n    }\\n\\n    /**\\n     * @dev Increases a Pool's 'cash' (and therefore its 'total'). Called when Pool tokens are sent to the Vault (except\\n     * when an Asset Manager action decreases the managed balance).\\n     */\\n    function increaseCash(bytes32 balance, uint256 amount) internal view returns (bytes32) {\\n        uint256 newCash = cash(balance).add(amount);\\n        uint256 currentManaged = managed(balance);\\n        uint256 newBlockNumber = block.number;\\n\\n        return toBalance(newCash, currentManaged, newBlockNumber);\\n    }\\n\\n    /**\\n     * @dev Decreases a Pool's 'cash' (and therefore its 'total'). Called when Pool tokens are sent from the Vault\\n     * (except as an Asset Manager action that increases the managed balance).\\n     */\\n    function decreaseCash(bytes32 balance, uint256 amount) internal view returns (bytes32) {\\n        uint256 newCash = cash(balance).sub(amount);\\n        uint256 currentManaged = managed(balance);\\n        uint256 newBlockNumber = block.number;\\n\\n        return toBalance(newCash, currentManaged, newBlockNumber);\\n    }\\n\\n    /**\\n     * @dev Moves 'cash' into 'managed', leaving 'total' unchanged. Called when Pool tokens are sent from the Vault\\n     * when an Asset Manager action increases the managed balance.\\n     */\\n    function cashToManaged(bytes32 balance, uint256 amount) internal pure returns (bytes32) {\\n        uint256 newCash = cash(balance).sub(amount);\\n        uint256 newManaged = managed(balance).add(amount);\\n        uint256 currentBlockNumber = blockNumber(balance);\\n\\n        return toBalance(newCash, newManaged, currentBlockNumber);\\n    }\\n\\n    /**\\n     * @dev Moves 'managed' into 'cash', leaving 'total' unchanged. Called when Pool tokens are sent to the Vault when\\n     * an Asset Manager action decreases the managed balance.\\n     */\\n    function managedToCash(bytes32 balance, uint256 amount) internal pure returns (bytes32) {\\n        uint256 newCash = cash(balance).add(amount);\\n        uint256 newManaged = managed(balance).sub(amount);\\n        uint256 currentBlockNumber = blockNumber(balance);\\n\\n        return toBalance(newCash, newManaged, currentBlockNumber);\\n    }\\n\\n    /**\\n     * @dev Sets 'managed' balance to an arbitrary value, changing 'total'. Called when the Asset Manager reports\\n     * profits or losses. It's the Manager's responsibility to provide a meaningful value.\\n     */\\n    function setManaged(bytes32 balance, uint256 newManaged) internal view returns (bytes32) {\\n        uint256 currentCash = cash(balance);\\n        uint256 newBlockNumber = block.number;\\n        return toBalance(currentCash, newManaged, newBlockNumber);\\n    }\\n\\n    // Alternative mode for Pools with the two token specialization setting\\n\\n    // Instead of storing cash and external for each token in a single storage slot, two token pools store the cash for\\n    // both tokens in the same slot, and the external for both in another one. This reduces the gas cost for swaps,\\n    // because the only slot that needs to be updated is the one with the cash. However, it also means that managing\\n    // balances is more cumbersome, as both tokens need to be read/written at the same time.\\n    //\\n    // The field with both cash balances packed is called sharedCash, and the one with external amounts is called\\n    // sharedManaged. These two are collectively called the 'shared' balance fields. In both of these, the portion\\n    // that corresponds to token A is stored in the least significant 112 bits of a 256 bit word, while token B's part\\n    // uses the next least significant 112 bits.\\n    //\\n    // Because only cash is written to during a swap, we store the block number there. Typically Pools have a distinct\\n    // block number per token: in the case of two token Pools this is not necessary, as both values will be the same.\\n\\n    /**\\n     * @dev Unpacks the shared token A and token B cash and managed balances into the balance for token A.\\n     */\\n    function fromSharedToBalanceA(bytes32 sharedCash, bytes32 sharedManaged) internal pure returns (bytes32) {\\n        return toBalance(_decodeBalanceA(sharedCash), _decodeBalanceA(sharedManaged), blockNumber(sharedCash));\\n    }\\n\\n    /**\\n     * @dev Unpacks the shared token A and token B cash and managed balances into the balance for token B.\\n     */\\n    function fromSharedToBalanceB(bytes32 sharedCash, bytes32 sharedManaged) internal pure returns (bytes32) {\\n        return toBalance(_decodeBalanceB(sharedCash), _decodeBalanceB(sharedManaged), blockNumber(sharedCash));\\n    }\\n\\n    /**\\n     * @dev Returns the sharedCash shared field, given the current balances for tokenA and tokenB.\\n     */\\n    function toSharedCash(bytes32 tokenABalance, bytes32 tokenBBalance) internal pure returns (bytes32) {\\n        // Both balances have the block number. Since both balances are always updated at the same time,\\n        // it does not matter where we pick it from.\\n        return _pack(cash(tokenABalance), cash(tokenBBalance), blockNumber(tokenABalance));\\n    }\\n\\n    /**\\n     * @dev Returns the sharedManaged shared field, given the current balances for tokenA and tokenB.\\n     */\\n    function toSharedManaged(bytes32 tokenABalance, bytes32 tokenBBalance) internal pure returns (bytes32) {\\n        return _pack(managed(tokenABalance), managed(tokenBBalance), 0);\\n    }\\n\\n    /**\\n     * @dev Unpacks the balance corresponding to token A for a shared balance\\n     * Note that this function can be used to decode both cash and managed balances.\\n     */\\n    function _decodeBalanceA(bytes32 sharedBalance) private pure returns (uint256) {\\n        uint256 mask = 2**(112) - 1;\\n        return uint256(sharedBalance) & mask;\\n    }\\n\\n    /**\\n     * @dev Unpacks the balance corresponding to token B for a shared balance\\n     * Note that this function can be used to decode both cash and managed balances.\\n     */\\n    function _decodeBalanceB(bytes32 sharedBalance) private pure returns (uint256) {\\n        uint256 mask = 2**(112) - 1;\\n        return uint256(sharedBalance >> 112) & mask;\\n    }\\n\\n    // Shared functions\\n\\n    /**\\n     * @dev Packs together two uint112 and one uint32 into a bytes32\\n     */\\n    function _pack(\\n        uint256 _leastSignificant,\\n        uint256 _midSignificant,\\n        uint256 _mostSignificant\\n    ) private pure returns (bytes32) {\\n        return bytes32((_mostSignificant << 224) + (_midSignificant << 112) + _leastSignificant);\\n    }\\n}\\n\",\"keccak256\":\"0xb4dee0dea9407a3956cbbea3be9e1100a06fb34a9604d448979e0120d99f2e1f\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/IAsset.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev This is an empty interface used to represent either token contracts that adhere to the IERC20 interface,\\n * or a sentinel value that represents ETH (the zero address). We're just relying on the fact that `interface` can be\\n * used to declare new address-like types.\\n *\\n * This concept is unrelated to a Pool's Asset Managers.\\n */\\ninterface IAsset {\\n    // solhint-disable-previous-line no-empty-blocks\\n}\\n\",\"keccak256\":\"0x14ea372a2bc6f936a14632bc4cf126e0cdf522fdcd16f5bfe1a922878179d5f9\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/IAuthorizer.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\ninterface IAuthorizer {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x998d8893c0ab3bbeec0ad091efb7f97d44fb68c5c58a38d61ab801eec514391c\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/IBasePool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IVault.sol\\\";\\nimport \\\"./IPoolSwapStructs.sol\\\";\\n\\n/**\\n * @dev Interface for adding and removing liquidity that all Pool contracts should implement. Note that this is not\\n * the complete Pool contract interface, as it is missing the swap hooks. Pool contracts should also inherit from\\n * either IGeneralPool or IMinimalSwapInfoPool\\n */\\ninterface IBasePool is IPoolSwapStructs {\\n    /**\\n     * @dev Called by the Vault when a user calls `IVault.joinPool` to add liquidity to this Pool. Returns how many of\\n     * each registered token the user should provide, as well as the amount of protocol fees the Pool owes to the Vault.\\n     * The Vault will then take tokens from `sender` and add them to the Pool's balances, as well as collect\\n     * the reported amount in protocol fees, which the pool should calculate based on the `protocolSwapFee` percentage.\\n     *\\n     * Protocol fees are reported and charged on join events so that the Pool is free of debt whenever new users join.\\n     *\\n     * `sender` is the account performing the join (from whom tokens will be withdrawn), and `recipient` is the account\\n     * designated to receive any benefits (typically pool shares). `currentBalances` contains the total balances\\n     * for each token the Pool registered in the Vault, in the same order that `IVault.getPoolTokens` would return.\\n     *\\n     * `latestBlockNumberUsed` is the last block number in which any of the Pool's registered tokens last changed its\\n     * balance. This can be used to implement price oracles that are resilient to 'sandwich' attacks.\\n     *\\n     * `userData` contains any pool-specific instructions needed to perform the calculations, such as the type of\\n     * join (e.g., proportional given an amount of pool shares, single-asset, multi-asset, etc.)\\n     *\\n     * Contracts implementing this function should check that the caller is indeed the Vault before performing any\\n     * state-changing operations, such as minting pool shares.\\n     */\\n    function onJoinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] calldata currentBalances,\\n        uint256 latestBlockNumberUsed,\\n        uint256 protocolSwapFee,\\n        bytes calldata userData\\n    ) external returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts);\\n\\n    /**\\n     * @dev Called by the Vault when a user calls `IVault.exitPool` to remove liquidity from this Pool. Returns how many\\n     * tokens the Vault should deduct from the Pool's balances, as well as the amount of protocol fees the Pool owes\\n     * to the Vault. The Vault will then take tokens from the Pool's balances and send them to `recipient`,\\n     * as well as collect the reported amount in protocol fees, which the Pool should calculate based on the\\n     * `protocolSwapFee` percentage.\\n     *\\n     * Protocol fees are reported and charged on exit events to guarantee that users exiting the Pool have paid\\n     * their share.\\n     *\\n     * `sender` is the account performing the exit (typically the pool shareholder), and `recipient` is the account\\n     * to which the Vault will send the proceeds. `currentBalances` contains the total token balances for each token\\n     * the Pool registered in the Vault, in the same order that `IVault.getPoolTokens` would return.\\n     *\\n     * `latestBlockNumberUsed` is the last block number in which any of the Pool's registered tokens last changed its\\n     * balance. This can be used to implement price oracles that are resilient to 'sandwich' attacks.\\n     *\\n     * `userData` contains any pool-specific instructions needed to perform the calculations, such as the type of\\n     * exit (e.g., proportional given an amount of pool shares, single-asset, multi-asset, etc.)\\n     *\\n     * Contracts implementing this function should check that the caller is indeed the Vault before performing any\\n     * state-changing operations, such as burning pool shares.\\n     */\\n    function onExitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        uint256[] calldata currentBalances,\\n        uint256 latestBlockNumberUsed,\\n        uint256 protocolSwapFee,\\n        bytes calldata userData\\n    ) external returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts);\\n\\n    /**\\n     * @dev This function returns the appreciation of one BPT relative to the\\n     * underlying tokens. This starts at 1 when the pool is created and grows over time\\n     * It's equivalent to Curve's get_virtual_price() function\\n     */\\n    function getRate() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x8da4b96732f09eb95d72ff8760309cabd045a8fe42cf74bfbf52c38d157eba75\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/IFlashLoanReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\n// Inspired by Aave Protocol's IFlashLoanReceiver\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IFlashLoanReceiver {\\n    function receiveFlashLoan(\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        uint256[] calldata feeAmounts,\\n        bytes calldata receiverData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x7e8edb04c4eb005a04e90b41f70ac354b7516bbd44fd00f5b923650a483b06f1\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/IPoolSwapStructs.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IVault.sol\\\";\\n\\ninterface IPoolSwapStructs {\\n    // This is not really an interface - it just defines common structs used by other interfaces: IGeneralPool and\\n    // IMinimalSwapInfoPool.\\n    //\\n    // This data structure represents a request for a token swap, where `kind` indicates the swap type (given in or\\n    // given out) which indicates whether or not the amount sent by the pool is known.\\n    //\\n    //\\n    // The pool receives `tokenIn` and sends `tokenOut`. `amount` is the number of `tokenIn` tokens the pool will take\\n    // in, or the number of `tokenOut` tokens the Pool will send out, depending on the given swap `kind`.\\n    //\\n    // All other fields are not strictly necessary for most swaps, but are provided to support advanced scenarios in\\n    // some Pools.\\n    //\\n    // `poolId` is the ID of the Pool involved in the swap - this is useful for Pool contracts that implement more than\\n    // one Pool.\\n    //\\n    // `from` is the origin address for the funds the Pool receives, and `to` is the destination address\\n    // where the Pool sends the outgoing tokens.\\n    //\\n    // `userData` is extra data provided by the caller - typically a signature from a trusted party.\\n    struct SwapRequest {\\n        IVault.SwapKind kind;\\n        IERC20 tokenIn;\\n        IERC20 tokenOut;\\n        uint256 amount;\\n        // Misc data\\n        bytes32 poolId;\\n        uint256 latestBlockNumberUsed;\\n        address from;\\n        address to;\\n        bytes userData;\\n    }\\n}\\n\",\"keccak256\":\"0x6dbb166767cfd32ad97b4f1b8eacb33cd8e36691a2df4b51475012f11283dfbb\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/ISignaturesValidator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\ninterface ISignaturesValidator {\\n    /**\\n     * @dev Get EIP712 domain separator\\n     */\\n    function getDomainSeparator() external view returns (bytes32);\\n\\n    /**\\n     * @dev Get next nonce for an address\\n     */\\n    function getNextNonce(address user) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x3d071b5a7b848222805a8f63e78c58190a586ec1ea5ca41d7a76802a78e30219\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/IVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IWETH.sol\\\";\\nimport \\\"./IAsset.sol\\\";\\nimport \\\"./IAuthorizer.sol\\\";\\nimport \\\"./IFlashLoanReceiver.sol\\\";\\nimport \\\"./ISignaturesValidator.sol\\\";\\nimport \\\"../ProtocolFeesCollector.sol\\\";\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\\n * don't override one of these declarations.\\n */\\ninterface IVault is ISignaturesValidator {\\n    // Generalities about the Vault:\\n    //\\n    // - Whenever documentation refers to 'tokens', it strictly refers to ERC20-compliant token contracts. Tokens are\\n    // transferred out of the Vault by calling the `IERC20.transfer` function, and transferred in by calling\\n    // `IERC20.transferFrom`. In these cases, the sender must have previously allowed the Vault to use their tokens by\\n    // calling `IERC20.approve`. The only deviation from the ERC20 standard that is supported is functions not returning\\n    // a boolean value: in these scenarios, a non-reverting call is assumed to be successful.\\n    //\\n    // - All non-view functions in the Vault are non-reentrant: calling them while another one is mid-execution (e.g.\\n    // while execution control is transferred to a token contract during a swap) will result in a revert. View\\n    // functions can be called in a re-reentrant way, but doing so might cause them to return inconsistent results.\\n    // Contracts calling view functions in the Vault must make sure the Vault has not already been entered.\\n    //\\n    // - View functions revert if referring to either unregistered Pools, or unregistered tokens for registered Pools.\\n\\n    // Authorizer\\n    //\\n    // Some system actions are permissioned, like setting and collecting protocol fees. This permissioning system exists\\n    // outside of the Vault in the Authorizer contract: the Vault simply calls the Authorizer to check if the caller\\n    // can perform a given action.\\n    // The only exceptions to this involve relayers. A relayer is an account (typically a contract) that can use the\\n    // Internal Balance and Vault allowance of other accounts. For an account to be able to wield this power,\\n    // two things must occur:\\n    //  - The Authorizer must allow the the relayer to call the functions associated with this permission.\\n    //    In other words, Balancer governance must specifically approve the functions each relayer can call\\n    //  - Each user must approve the relayer to act on their behalf\\n    // This double protection means users cannot be tricked into allowing malicious relayers (because they will not\\n    // have been allowed by the Authorizer), nor can malicious relayers approved by a compromised Authorizer drain\\n    // user funds, since they would also need to be approved by each individual user.\\n\\n    /**\\n     * @dev Returns the Vault's WETH instance.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function WETH() external view returns (IWETH);\\n\\n    /**\\n     * @dev Returns the Vault's Authorizer.\\n     */\\n    function getAuthorizer() external view returns (IAuthorizer);\\n\\n    /**\\n     * @dev Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this.\\n     */\\n    function changeAuthorizer(IAuthorizer newAuthorizer) external;\\n\\n    /**\\n     * @dev Returns true if `user` has allowed `relayer` to act as a relayer for them.\\n     */\\n    function hasAllowedRelayer(address user, address relayer) external view returns (bool);\\n\\n    /**\\n     * @dev Allows `relayer` to act as a relayer for `sender` if `allowed` is true, and disallows it otherwise.\\n     */\\n    function changeRelayerAllowance(\\n        address sender,\\n        address relayer,\\n        bool allowed\\n    ) external;\\n\\n    // Internal Balance\\n    //\\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance.\\n    // This Internal Balance can be withdrawn or transferred, and it can also be used when joining Pools or\\n    // performing swaps, with greatly reduced gas costs. Swaps and Pool exits can also deposit to\\n    // Internal Balance.\\n    //\\n    // Internal Balance functions feature batching, which means each call can be used to perform multiple operations of\\n    // the same kind (deposit, withdraw or transfer) at once.\\n\\n    /**\\n     * @dev Data for Internal Balance operations which include the possibility for ETH to be sent and\\n     * received without manual WETH wrapping or unwrapping.\\n     */\\n    struct UserBalanceOp {\\n        UserBalanceOpKind kind;\\n        IAsset asset;\\n        uint256 amount;\\n        address sender;\\n        address payable recipient;\\n    }\\n\\n    /**\\n     * @dev Returns `user`'s Internal Balance for a set of tokens.\\n     */\\n    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Performs a set of user balance operations (deposit internal, withdraw internal, transfer internal, or\\n     * transfer external) in the Vault. The array input allows users to make multiple operations in a single\\n     * transaction.\\n     *\\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\\n     */\\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\\n\\n    /**\\n     * `DEPOSIT_INTERNAL` increases the Internal Balance of the `recipient` account by  transferring tokens from the\\n     * corresponding `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\\n     * ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call. It will be\\n     * wrapped into WETH and deposited as that token. Any ETH amount remaining will be sent back to the caller (not the\\n     * sender, which is relevant for relayers).\\n     * Emits an `InternalBalanceChanged` event.\\n     *\\n     * `WITHDRAW_INTERNAL` decreases the Internal Balance of the `sender` by transferring tokens to the\\n     * `recipient` account.\\n     * ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\\n     * it to the recipient.\\n     * Emits an `InternalBalanceChanged` event.\\n     *\\n     * `TRANSFER_INTERNAL` transfers tokens from the Internal Balance the `sender` account to the Internal Balances\\n     * of `recipient`.\\n     * Reverts if the ETH sentinel value is passed.\\n     * Emit an `InternalBalanceChanged` event.\\n     *\\n     * `TRANSFER_EXTERNAL` transfers tokens from the Internal Balance of the `sender` account to the Internal Balances\\n     * of the `recipient`.\\n     * Reverts if the ETH sentinel value is passed.\\n     * Emit an `ExternalBalanceTransfer` event.\\n     */\\n    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }\\n\\n    /**\\n     * @dev Emitted when a user's Internal Balance changes, due to calls on the Internal Balance functions, or\\n     * to interacting with Pools using Internal Balance.\\n     *\\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use\\n     * the WETH address.\\n     */\\n    event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\\n\\n    /**\\n     * @dev Emitted when a user's allowance is used by the Vault to transfer tokens to an external account.\\n     */\\n    event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\\n\\n    // Pools\\n    //\\n    // There are three specialization settings for Pools, which allow for lower gas cost swaps, at the cost of reduced\\n    // functionality:\\n    //\\n    //  - general: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\\n    // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\\n    // and these increase with the number of registered tokens.\\n    //\\n    //  - minimal swap info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\\n    // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\\n    // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\\n    // independent of the number of registered tokens.\\n    //\\n    //  - two tokens: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\\n    // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\\n\\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\\n\\n    /**\\n     * @dev Registers the caller contract as a Pool with a chosen specialization setting. Returns the Pool's ID,\\n     * which is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization\\n     * be changed.\\n     *\\n     * The caller is expected to be a smart contract that implements one of `IGeneralPool` or `IMinimalSwapInfoPool`.\\n     * This contract is known as the Pool's contract. Note that the same caller may register itself as multiple Pools\\n     * with unique Pool IDs, or in other words, multiple Pools may have the same contract.\\n     *\\n     * Emits a `PoolRegistered` event.\\n     */\\n    function registerPool(PoolSpecialization specialization) external returns (bytes32);\\n\\n    /**\\n     * @dev Emitted when a Pool is registered by calling `registerPool`.\\n     */\\n    event PoolRegistered(bytes32 poolId);\\n\\n    /**\\n     * @dev Returns a Pool's contract address and specialization setting.\\n     */\\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\\n\\n    /**\\n     * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\\n     * exit by receiving registered tokens, and can only swap registered tokens.\\n     *\\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\\n     * of two, that is, both tokens must be registered in the same `registerTokens` call.\\n     *\\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\\n     * Manager for each token. Asset Managers can manage a Pool's tokens by withdrawing and depositing them directly\\n     * (via `managePoolBalance` with the appropriate AssetManagerOpKind setting), and even set them to arbitrary amounts\\n     * with the UPDATE OpKind. They are therefore expected to be highly secured smart contracts with sound design\\n     * principles, and the decision to add an Asset Manager should not be made lightly.\\n     *\\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. However, once an\\n     * Asset Manager is set, it cannot be changed except by deregistering the associated token and registering again\\n     * with a different Asset Manager.\\n     *\\n     * Emits `TokensRegistered` events.\\n     */\\n    function registerTokens(\\n        bytes32 poolId,\\n        IERC20[] calldata tokens,\\n        address[] calldata assetManagers\\n    ) external;\\n\\n    /**\\n     * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\\n     */\\n    event TokensRegistered(bytes32 poolId, IERC20[] tokens, address[] assetManagers);\\n\\n    /**\\n     * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\\n     * must be deregistered in the same `deregisterTokens` call.\\n     *\\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\\n     *\\n     * Emits a `TokensDeregistered` event.\\n     */\\n    function deregisterTokens(bytes32 poolId, IERC20[] calldata tokens) external;\\n\\n    /**\\n     * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\\n     */\\n    event TokensDeregistered(bytes32 poolId, IERC20[] tokens);\\n\\n    /**\\n     * @dev Returns a Pool's registered tokens, and the total balance for each.\\n     *\\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\\n     *\\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\\n     * order as passed to `registerTokens`.\\n     *\\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\\n     * the amounts used by joins, exits and swaps.\\n     */\\n    function getPoolTokens(bytes32 poolId)\\n        external\\n        view\\n        returns (\\n            IERC20[] memory tokens,\\n            uint256[] memory balances,\\n            uint256 maxBlockNumber\\n        );\\n\\n    /**\\n     * @dev Returns detailed information for a Pool's registered token.\\n     *\\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\\n     * equals the sum of `cash` and `managed`.\\n     *\\n     * `blockNumber` is the number of the block in which `token`'s balance was last modified (via either a join, exit,\\n     * swap, or Asset Management interaction). This value is useful to avoid so-called 'sandwich attacks', for example\\n     * when developing price oracles.\\n     *\\n     * `assetManager` is the Pool's token Asset Manager.\\n     */\\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\\n        external\\n        view\\n        returns (\\n            uint256 cash,\\n            uint256 managed,\\n            uint256 blockNumber,\\n            address assetManager\\n        );\\n\\n    struct PoolBalanceChange {\\n        IAsset[] assets;\\n        uint256[] limits;\\n        bytes userData;\\n        bool useInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\\n     * Pool shares.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\\n     * these maximums.\\n     *\\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\\n     * back to the caller (not the sender, which is important for relayers).\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\\n     * sorted *before* replacing the WETH address with the ETH address, which means the final `assets` array might not\\n     * be sorted.\\n     *\\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\\n     *\\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\\n     * directly to the Pool's contract, as is `recipient`.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n    function joinPool(\\n        bytes32 poolId,\\n        address sender,\\n        address recipient,\\n        JoinPoolRequest memory request\\n    ) external payable;\\n\\n    struct JoinPoolRequest {\\n        IAsset[] assets;\\n        uint256[] maxAmountsIn;\\n        bytes userData;\\n        bool fromInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\\n     * `getPoolTokenInfo`).\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\\n     * it just enforces these minimums.\\n     *\\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\\n     * be sorted *before* replacing the WETH address with the ETH address, which means the final `assets` array might\\n     * not be sorted.\\n     *\\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\\n     * do so will trigger a revert.\\n     *\\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\\n     * `tokens` array. This array must match the Pool's registered tokens.\\n     *\\n     * Pools are free to implement any arbitrary logic in the `IPool.onExitPool` hook, and may require additional\\n     * information (such as the number of Pool shares to provide). This can be encoded in the `userData` argument, which\\n     * is ignored by the Vault and passed directly to the Pool.\\n     *\\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\\n     * passed directly to the Pool's contract.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n    function exitPool(\\n        bytes32 poolId,\\n        address sender,\\n        address payable recipient,\\n        ExitPoolRequest memory request\\n    ) external;\\n\\n    struct ExitPoolRequest {\\n        IAsset[] assets;\\n        uint256[] minAmountsOut;\\n        bytes userData;\\n        bool toInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool` respectively.\\n     */\\n    event PoolBalanceChanged(\\n        bytes32 indexed poolId,\\n        address indexed liquidityProvider,\\n        IERC20[] tokens,\\n        int256[] amounts,\\n        uint256[] protocolFees\\n    );\\n\\n    enum PoolBalanceChangeKind { JOIN, EXIT }\\n\\n    // Swaps\\n    //\\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\\n    //\\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\\n    // individual swaps.\\n    //\\n    // There are two swap kinds:\\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\\n    //\\n    // Additionally, it is possible to chain swaps by using the output of one as the input to the next (for given in\\n    // swaps), as well as using inputs of one as the previous one (for given out swaps). These extended swaps are known\\n    // as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at the final\\n    // intended token.\\n    //\\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\\n    // much less gas than they would otherwise.\\n    //\\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\\n    // updating the Pool's internal accounting).\\n    //\\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\\n    //\\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\\n    //\\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\\n    //\\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\\n\\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\\n\\n    /**\\n     * @dev Performs a swap with a single Pool.\\n     *\\n     * If the swap is given in (the number of tokens to send to the Pool is known), returns the amount of tokens\\n     * taken from the Pool, which must be larger or equal to `limit`.\\n     *\\n     * If the swap is given out (the number of tokens to take from the Pool is known), returns the amount of\\n     * tokens sent to the Pool, which must be smaller or equal to `limit`.\\n     *\\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\\n     *\\n     * Emits a `Swap` event.\\n     */\\n    function swap(\\n        SingleSwap memory request,\\n        FundManagement memory funds,\\n        uint256 limit,\\n        uint256 deadline\\n    ) external payable returns (uint256);\\n\\n    /**\\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\\n     * the `kind` value.\\n     *\\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value (the zero address) for ETH.\\n     * Note that Pools never interact with ETH directly: it will be wrapped or unwrapped using WETH by the Vault.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n    struct SingleSwap {\\n        bytes32 poolId;\\n        SwapKind kind;\\n        IAsset assetIn;\\n        IAsset assetOut;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\\n     * the amount of tokens sent to or received from the Pool depending on the `kind` value.\\n     *\\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\\n     * Vault, and negative amounts tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at the same\\n     * index in the `assets` array.\\n     *\\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\\n     * `amountOut` depending on the swap kind.\\n     *\\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\\n     * of the previous swap to be used as the amount in for the current one. In such a scenario, `tokenIn` must equal\\n     * the previous swap's `tokenOut` in case of a swap given in, or `tokenOut` must equal the previous swap's `tokenIn`\\n     * in case of a swap given out.\\n     *\\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\\n     * or the IAsset sentinel value (the zero address) for ETH. Each entry in the `swaps` array specifies tokens in and\\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped or\\n     * unwrapped using WETH by the Vault.\\n     *\\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\\n     *\\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\\n     * euivalent `swap` call.\\n     *\\n     * Emits `Swap` events.\\n     */\\n    function batchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] calldata swaps,\\n        IAsset[] memory assets,\\n        FundManagement calldata funds,\\n        int256[] memory limits,\\n        uint256 deadline\\n    ) external payable returns (int256[] memory);\\n\\n    /**\\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out are indexed in the\\n     * `assets` array passed to that function, where an ETH asset is translated into WETH.\\n     *\\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\\n     * from the previous swap depending on the swap kind specified.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n    struct BatchSwapStep {\\n        bytes32 poolId;\\n        uint256 assetInIndex;\\n        uint256 assetOutIndex;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    /**\\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\\n     */\\n    event Swap(\\n        bytes32 indexed poolId,\\n        IERC20 indexed tokenIn,\\n        IERC20 indexed tokenOut,\\n        uint256 tokensIn,\\n        uint256 tokensOut\\n    );\\n\\n    /**\\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\\n     * `recipient` account.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\\n     * `joinPool`.\\n     *\\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\\n     * transferred. This matches the behavior of `exitPool`.\\n     *\\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\\n     * revert.\\n     */\\n    struct FundManagement {\\n        address sender;\\n        bool fromInternalBalance;\\n        address payable recipient;\\n        bool toInternalBalance;\\n    }\\n\\n    /**\\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\\n     *\\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\\n     * receives are the same that an equivalent `batchSwap` call would receive.\\n     *\\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\\n     * approve them for the Vault, or even know a user's address.\\n     *\\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\\n     * eth_call instead of eth_sendTransaction.\\n     */\\n    function queryBatchSwap(\\n        SwapKind kind,\\n        BatchSwapStep[] memory swaps,\\n        IAsset[] memory assets,\\n        FundManagement memory funds\\n    ) external returns (int256[] memory assetDeltas);\\n\\n    // Flash Loans\\n\\n    /**\\n     * @dev Performs a 'flash loan', sending tokens to `receiver` and executing the `receiveFlashLoan` hook on it,\\n     * and then reverting unless the tokens plus a protocol fee have been returned.\\n     *\\n     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the amount to\\n     * loan for each token contract. `tokens` must be sorted in ascending order.\\n     *\\n     * The 'receiverData' field is ignored by the Vault, and forwarded as-is to `receiver` as part of the\\n     * `receiveFlashLoan` call.\\n     */\\n    function flashLoan(\\n        IFlashLoanReceiver receiver,\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        bytes calldata receiverData\\n    ) external;\\n\\n    // Asset Management\\n    //\\n    // Each token registered for a Pool can be assigned an Asset Manager, which is able to freely withdraw the Pool's\\n    // tokens from the Vault, deposit them, or assign arbitrary values to its `managed` balance (see\\n    // `getPoolTokenInfo`). This makes them extremely powerful and dangerous. Even if an Asset Manager only directly\\n    // controls one of the tokens in a Pool, a malicious manager could set that token's balance to manipulate the\\n    // prices of the other tokens, and then drain the Pool with swaps. The risk of using Asset Managers is therefore\\n    // not constrained to the tokens they are managing, but extends to the entire Pool's holdings.\\n    //\\n    // However, a properly designed Asset Manager smart contract can be safely used for the Pool's benefit,\\n    // for example by lending unused tokens out for interest, or using them to participate in voting protocols.\\n    //\\n    // This concept is unrelated to the IAsset interface.\\n\\n    /**\\n     * @dev Called by a Pool's Asset Manager to perform an operation (withdraw, deposit, or update) in the Vault.\\n     * Array input allows asset managers to manage multiple tokens for a pool in a single transaction.\\n     */\\n    function managePoolBalance(\\n        bytes32 poolId,\\n        AssetManagerOpKind kind,\\n        AssetManagerTransfer[] memory transfers\\n    ) external;\\n\\n    struct AssetManagerTransfer {\\n        IERC20 token;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * @dev Emitted when a Pool's token Asset manager withdraws or deposits token balance via `managePoolBalance`\\n     * (using the AssetManagerOpKind to determine the type of update)\\n     */\\n    event PoolBalanceManaged(bytes32 indexed poolId, address indexed assetManager, IERC20 indexed token, int256 amount);\\n\\n    /**\\n     * Deposits increase the Pool's cash, but decrease its managed balance, leaving the total balance unchanged.\\n     *\\n     * Withdrawals decrease the Pool's cash, but increase its managed balance, leaving the total balance unchanged.\\n     *\\n     * Updates don't affect the Pool's cash balance, but because the managed balance changes, it does alter the total.\\n     * The external amount can be either increased or decreased by this call (i.e., reporting a gain or a loss).\\n     */\\n    enum AssetManagerOpKind { DEPOSIT, WITHDRAW, UPDATE }\\n\\n    // Protocol Fees\\n    //\\n    // Some operations cause the Vault to collect tokens in the form of protocol fees, which can then be withdrawn by\\n    // permissioned accounts.\\n    //\\n    // There are two kinds of protocol fees:\\n    //\\n    //  - flash loan fees: charged on all flash loans, as a percentage of the amounts lent.\\n    //\\n    //  - swap fees: a percentage of the fees charged by Pools when performing swaps. For a number of reasons, including\\n    // swap gas costs and interface simplicity, protocol swap fees are not charged on each individual swap. Rather,\\n    // Pools are expected to keep track of how many swap fees they have charged, and pay any outstanding debts to the\\n    // Vault when they are joined or exited. This prevents users from joining a Pool with unpaid debt, as well as\\n    // exiting a Pool in debt without first paying their share.\\n\\n    /**\\n     * @dev Returns the current protocol fee module.\\n     */\\n    function getProtocolFeesCollector() external view returns (ProtocolFeesCollector);\\n\\n    /**\\n     * @dev Safety mechanism to halt most Vault operations in the event of an emergency - typically detection\\n     * of an error in some part of the system.\\n     *\\n     * The emergency stop can only be activated during an initial time period, after which it is forever disabled.\\n     *\\n     * While the emergency stop is active, the following features are disabled:\\n     * - depositing and transferring internal balance\\n     * - transferring external balance (using the Vault's allowance)\\n     * - swaps\\n     * - joining Pools\\n     *\\n     * Internal balance can still be withdrawn, and Pools exited.\\n     */\\n    function setEmergencyPeriod(bool active) external;\\n}\\n\",\"keccak256\":\"0xf2d7e01a31f3934cb18d14462dda0db0ed88d35fa359b8ee020a646a5dd63960\",\"license\":\"GPL-3.0-or-later\"},\"contracts/vault/interfaces/IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x8c56cefdfaa6fed05a4f0d0b92957ec4df5ff734c0845a5a76353782be1a6644\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x60c060405234801561001057600080fd5b5060405161100d38038061100d83398101604081905261002f916100bf565b806001600160a01b031663ad5c46486040518163ffffffff1660e01b815260040160206040518083038186803b15801561006857600080fd5b505afa15801561007c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100a091906100bf565b6001600160601b0319606091821b811660805291901b1660a0526100fa565b6000602082840312156100d0578081fd5b81516100db816100e2565b9392505050565b6001600160a01b03811681146100f757600080fd5b50565b60805160601c60a05160601c610ed261013b6000398060a0528061016352806103545280610417528061051e52806105905250806108565250610ed26000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80639ebbf05d14610046578063c7b2c52c14610070578063fbfa77cf14610083575b600080fd5b610059610054366004610c5b565b610098565b604051610067929190610e0f565b60405180910390f35b61005961007e366004610bf1565b61034c565b61008b61051c565b6040516100679190610dee565b6000606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f6c00927886040518263ffffffff1660e01b81526004016100f79190610d2a565b604080518083038186803b15801561010e57600080fd5b505afa158015610122573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101469190610ae9565b5090506060600061015b898760000151610540565b9150915060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d2946c2b6040518163ffffffff1660e01b815260040160206040518083038186803b1580156101c757600080fd5b505afa1580156101db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ff9190610c70565b90508373ffffffffffffffffffffffffffffffffffffffff166387ec68178b8b8b87878773ffffffffffffffffffffffffffffffffffffffff1663d4cadf686040518163ffffffff1660e01b815260040160206040518083038186803b15801561026857600080fd5b505afa15801561027c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102a09190610c93565b8e604001516040518863ffffffff1660e01b81526004016102c79796959493929190610d33565b600060405180830381600087803b1580156102e157600080fd5b505af11580156102f5573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261033b9190810190610cab565b909b909a5098505050505050505050565b6000606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f6c00927886040518263ffffffff1660e01b81526004016103ab9190610d2a565b604080518083038186803b1580156103c257600080fd5b505afa1580156103d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103fa9190610ae9565b5090506060600061040f898760000151610540565b9150915060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d2946c2b6040518163ffffffff1660e01b815260040160206040518083038186803b15801561047b57600080fd5b505afa15801561048f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104b39190610c70565b90508373ffffffffffffffffffffffffffffffffffffffff16636028bfd48b8b8b87878773ffffffffffffffffffffffffffffffffffffffff1663d4cadf686040518163ffffffff1660e01b815260040160206040518083038186803b15801561026857600080fd5b7f000000000000000000000000000000000000000000000000000000000000000081565b60606000606080610550856106d2565b6040517ff94d466800000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063f94d4668906105c5908990600401610d2a565b60006040518083038186803b1580156105dd57600080fd5b505afa1580156105f1573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526106379190810190610b25565b8251845192975090955091935061064e9190610780565b60005b82518110156106c857600083828151811061066857fe5b602002602001015190506106bf83838151811061068157fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161461026b610791565b50600101610651565b5050509250929050565b6060815167ffffffffffffffff811180156106ec57600080fd5b50604051908082528060200260200182016040528015610716578160200160208202803683370190505b50905060005b825181101561077a5761074183828151811061073457fe5b602002602001015161079f565b82828151811061074d57fe5b73ffffffffffffffffffffffffffffffffffffffff9092166020928302919091019091015260010161071c565b50919050565b61078d8183146067610791565b5050565b8161078d5761078d816107ca565b60006107aa82610837565b6107bc576107b782610851565b6107c4565b6107c4610854565b92915050565b7f08c379a0000000000000000000000000000000000000000000000000000000006000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b73ffffffffffffffffffffffffffffffffffffffff161590565b90565b7f000000000000000000000000000000000000000000000000000000000000000090565b600082601f830112610888578081fd5b813561089b61089682610e57565b610e30565b8181529150602080830190848101818402860182018710156108bc57600080fd5b60005b848110156108e45781356108d281610e77565b845292820192908201906001016108bf565b505050505092915050565b600082601f8301126108ff578081fd5b813561090d61089682610e57565b81815291506020808301908481018184028601820187101561092e57600080fd5b60005b848110156108e457813584529282019290820190600101610931565b600082601f83011261095d578081fd5b815161096b61089682610e57565b81815291506020808301908481018184028601820187101561098c57600080fd5b60005b848110156108e45781518452928201929082019060010161098f565b803580151581146107c457600080fd5b600082601f8301126109cb578081fd5b813567ffffffffffffffff8111156109e1578182fd5b610a1260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601610e30565b9150808252836020828501011115610a2957600080fd5b8060208401602084013760009082016020015292915050565b600060808284031215610a53578081fd5b610a5d6080610e30565b9050813567ffffffffffffffff80821115610a7757600080fd5b610a8385838601610878565b83526020840135915080821115610a9957600080fd5b610aa5858386016108ef565b60208401526040840135915080821115610abe57600080fd5b50610acb848285016109bb565b604083015250610ade83606084016109ab565b606082015292915050565b60008060408385031215610afb578182fd5b8251610b0681610e77565b602084015190925060038110610b1a578182fd5b809150509250929050565b600080600060608486031215610b39578081fd5b835167ffffffffffffffff80821115610b50578283fd5b818601915086601f830112610b63578283fd5b8151610b7161089682610e57565b80828252602080830192508086018b828387028901011115610b91578788fd5b8796505b84871015610bbc578051610ba881610e77565b845260019690960195928101928101610b95565b508901519097509350505080821115610bd3578283fd5b50610be08682870161094d565b925050604084015190509250925092565b60008060008060808587031215610c06578081fd5b843593506020850135610c1881610e77565b92506040850135610c2881610e77565b9150606085013567ffffffffffffffff811115610c43578182fd5b610c4f87828801610a42565b91505092959194509250565b60008060008060808587031215610c06578384fd5b600060208284031215610c81578081fd5b8151610c8c81610e77565b9392505050565b600060208284031215610ca4578081fd5b5051919050565b60008060408385031215610cbd578182fd5b82519150602083015167ffffffffffffffff811115610cda578182fd5b610ce68582860161094d565b9150509250929050565b6000815180845260208085019450808401835b83811015610d1f57815187529582019590820190600101610d03565b509495945050505050565b90815260200190565b6000888252602073ffffffffffffffffffffffffffffffffffffffff808a168285015280891660408501525060e06060840152610d7360e0840188610cf0565b8660808501528560a085015283810360c08501528451808252835b81811015610da9578681018401518382018501528301610d8e565b81811115610db957848483850101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01601019998505050505050505050565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b600083825260406020830152610e286040830184610cf0565b949350505050565b60405181810167ffffffffffffffff81118282101715610e4f57600080fd5b604052919050565b600067ffffffffffffffff821115610e6d578081fd5b5060209081020190565b73ffffffffffffffffffffffffffffffffffffffff81168114610e9957600080fd5b5056fea2646970667358221220e30ea831c02243ca742fff3f863be3dd921ffc76df13a2d3ae4e44c1b347d35564736f6c63430007010033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c80639ebbf05d14610046578063c7b2c52c14610070578063fbfa77cf14610083575b600080fd5b610059610054366004610c5b565b610098565b604051610067929190610e0f565b60405180910390f35b61005961007e366004610bf1565b61034c565b61008b61051c565b6040516100679190610dee565b6000606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f6c00927886040518263ffffffff1660e01b81526004016100f79190610d2a565b604080518083038186803b15801561010e57600080fd5b505afa158015610122573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101469190610ae9565b5090506060600061015b898760000151610540565b9150915060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d2946c2b6040518163ffffffff1660e01b815260040160206040518083038186803b1580156101c757600080fd5b505afa1580156101db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ff9190610c70565b90508373ffffffffffffffffffffffffffffffffffffffff166387ec68178b8b8b87878773ffffffffffffffffffffffffffffffffffffffff1663d4cadf686040518163ffffffff1660e01b815260040160206040518083038186803b15801561026857600080fd5b505afa15801561027c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102a09190610c93565b8e604001516040518863ffffffff1660e01b81526004016102c79796959493929190610d33565b600060405180830381600087803b1580156102e157600080fd5b505af11580156102f5573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261033b9190810190610cab565b909b909a5098505050505050505050565b6000606060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663f6c00927886040518263ffffffff1660e01b81526004016103ab9190610d2a565b604080518083038186803b1580156103c257600080fd5b505afa1580156103d6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103fa9190610ae9565b5090506060600061040f898760000151610540565b9150915060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1663d2946c2b6040518163ffffffff1660e01b815260040160206040518083038186803b15801561047b57600080fd5b505afa15801561048f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104b39190610c70565b90508373ffffffffffffffffffffffffffffffffffffffff16636028bfd48b8b8b87878773ffffffffffffffffffffffffffffffffffffffff1663d4cadf686040518163ffffffff1660e01b815260040160206040518083038186803b15801561026857600080fd5b7f000000000000000000000000000000000000000000000000000000000000000081565b60606000606080610550856106d2565b6040517ff94d466800000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000169063f94d4668906105c5908990600401610d2a565b60006040518083038186803b1580156105dd57600080fd5b505afa1580156105f1573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526106379190810190610b25565b8251845192975090955091935061064e9190610780565b60005b82518110156106c857600083828151811061066857fe5b602002602001015190506106bf83838151811061068157fe5b602002602001015173ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161461026b610791565b50600101610651565b5050509250929050565b6060815167ffffffffffffffff811180156106ec57600080fd5b50604051908082528060200260200182016040528015610716578160200160208202803683370190505b50905060005b825181101561077a5761074183828151811061073457fe5b602002602001015161079f565b82828151811061074d57fe5b73ffffffffffffffffffffffffffffffffffffffff9092166020928302919091019091015260010161071c565b50919050565b61078d8183146067610791565b5050565b8161078d5761078d816107ca565b60006107aa82610837565b6107bc576107b782610851565b6107c4565b6107c4610854565b92915050565b7f08c379a0000000000000000000000000000000000000000000000000000000006000908152602060045260076024526642414c23000030600a808404818106603090810160081b95839006959095019082900491820690940160101b939093010160c81b604452606490fd5b73ffffffffffffffffffffffffffffffffffffffff161590565b90565b7f000000000000000000000000000000000000000000000000000000000000000090565b600082601f830112610888578081fd5b813561089b61089682610e57565b610e30565b8181529150602080830190848101818402860182018710156108bc57600080fd5b60005b848110156108e45781356108d281610e77565b845292820192908201906001016108bf565b505050505092915050565b600082601f8301126108ff578081fd5b813561090d61089682610e57565b81815291506020808301908481018184028601820187101561092e57600080fd5b60005b848110156108e457813584529282019290820190600101610931565b600082601f83011261095d578081fd5b815161096b61089682610e57565b81815291506020808301908481018184028601820187101561098c57600080fd5b60005b848110156108e45781518452928201929082019060010161098f565b803580151581146107c457600080fd5b600082601f8301126109cb578081fd5b813567ffffffffffffffff8111156109e1578182fd5b610a1260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601610e30565b9150808252836020828501011115610a2957600080fd5b8060208401602084013760009082016020015292915050565b600060808284031215610a53578081fd5b610a5d6080610e30565b9050813567ffffffffffffffff80821115610a7757600080fd5b610a8385838601610878565b83526020840135915080821115610a9957600080fd5b610aa5858386016108ef565b60208401526040840135915080821115610abe57600080fd5b50610acb848285016109bb565b604083015250610ade83606084016109ab565b606082015292915050565b60008060408385031215610afb578182fd5b8251610b0681610e77565b602084015190925060038110610b1a578182fd5b809150509250929050565b600080600060608486031215610b39578081fd5b835167ffffffffffffffff80821115610b50578283fd5b818601915086601f830112610b63578283fd5b8151610b7161089682610e57565b80828252602080830192508086018b828387028901011115610b91578788fd5b8796505b84871015610bbc578051610ba881610e77565b845260019690960195928101928101610b95565b508901519097509350505080821115610bd3578283fd5b50610be08682870161094d565b925050604084015190509250925092565b60008060008060808587031215610c06578081fd5b843593506020850135610c1881610e77565b92506040850135610c2881610e77565b9150606085013567ffffffffffffffff811115610c43578182fd5b610c4f87828801610a42565b91505092959194509250565b60008060008060808587031215610c06578384fd5b600060208284031215610c81578081fd5b8151610c8c81610e77565b9392505050565b600060208284031215610ca4578081fd5b5051919050565b60008060408385031215610cbd578182fd5b82519150602083015167ffffffffffffffff811115610cda578182fd5b610ce68582860161094d565b9150509250929050565b6000815180845260208085019450808401835b83811015610d1f57815187529582019590820190600101610d03565b509495945050505050565b90815260200190565b6000888252602073ffffffffffffffffffffffffffffffffffffffff808a168285015280891660408501525060e06060840152610d7360e0840188610cf0565b8660808501528560a085015283810360c08501528451808252835b81811015610da9578681018401518382018501528301610d8e565b81811115610db957848483850101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01601019998505050505050505050565b73ffffffffffffffffffffffffffffffffffffffff91909116815260200190565b600083825260406020830152610e286040830184610cf0565b949350505050565b60405181810167ffffffffffffffff81118282101715610e4f57600080fd5b604052919050565b600067ffffffffffffffff821115610e6d578081fd5b5060209081020190565b73ffffffffffffffffffffffffffffffffffffffff81168114610e9957600080fd5b5056fea2646970667358221220e30ea831c02243ca742fff3f863be3dd921ffc76df13a2d3ae4e44c1b347d35564736f6c63430007010033",
  "devdoc": {
    "details": "This contract simply builds on top of the Balancer V2 architecture to provide useful helpers to users. It connects different functionalities of the protocol components to allow accessing information that would have required a more cumbersome setup if we wanted to provide these already built-in.",
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}